# recun1sw

On 11/11/2021 I made a mistake. I bought a smart watch [Cubot N1](https://www.cubot.net/wearables/N1) to monitor my heart rate while out running. After a few weeks of use I realized that the measurements, to put it mildly, are only approximate. In addition, the cell phone app leaves something to be desired and is not open source, so it is not possible to know where my personal data ends up. In short, I realized that the Cubot N1 smartwatch is junk and I had thrown my money away.

Mistake noted, I decided to have fun with the watch in another way: reverse engineer the communication protocol the watch uses to send data to the cell phone app. Once I knew how the watch passes the measurements to the cell phone application I could make a small Linux application that would display graphs of the samples taken by the watch.

The reason for making a Linux app and not making an Android app is, frankly, that I know absolutely nothing about Android development. If I did, I would have probably made a PR to an existing app like [Gadgetbridge](https://codeberg.org/Freeyourgadget/Gadgetbridge/).

Once I had the goal set, I established the steps to achieve it:

 1. Reverse engineer the protocol that the watch and the cell phone app use to communicate. This can be accomplished in two ways:
         - Decompile the mobile [app](https://play.google.com/store/apps/details?id=com.yc.gloryfit) that Cubot provides to manage the watch.
         - Capture the Bluetooth traffic between the watch and the cell phone application and inspect it with a traffic analyzer such as Wireshark.
 2. Confirm and extend the knowledge gained in the previous step using small, easy-to-develop scripts.
 3. Develop a Linux application that would communicate with the clock and display graphs of the data obtained by the clock.

## Reverse engineering of the communication protocol.
### Decompile the App
 The most obvious starting point for obtaining information about the communication protocol between the clock and the App is the App itself. Unfortunately, at the time I tried to decompile it, the App appeared to be protected by [Tencent's Legu Packer](https://github.com/quarkslab/legu_unpacker_2019) and I wasn't able to deofuscate the code. It was very frustrating. If it was at least a properly functioning app I could understand the caution that no one else use their superb code, but it's just that the performance of the app leaves something to be desired.

### Capture Bluetooth traffic between the watch and the App.
On the previous phone I had, an Android 7, the easiest way to capture Bluetooth traffic was to enable the [developer](https://developer.android.com/studio/debug/dev-options) options on the phone, enable the [Bluetooth](https://developer.android.com/studio/debug/dev-options#general) Host Controller Interface (HCI) snoop log, and examine the file created by the phone with [Wireshark](https://www.wireshark.org/). To copy the file containing the Bluetooth traffic capture, called `btsnoop_hci.log`, from the phone to the computer I used [KDE Connect](https://kdeconnect.kde.org/) which is installed by default in [Kubuntu](https://kubuntu.org/), the distribution I use. A straightforward process that was not complicated.

With the new phone I have now, an Android 10, the process has not been so easy. The only simple and quick way I have found to get a capture of the Bluetooth traffic has been:

1. Install [Wireshark](https://www.wireshark.org/) and [adb](https://developer.android.com/studio/command-line/adb) on the computer with `sudo apt install wireshark-qt adb`.
 2. [Enable](https://developer.android.com/studio/debug/dev-options) on the phone the developer options.
 3. [Enable](https://developer.android.com/studio/debug/dev-options#enable) USB debugging.
 4. [Enable](https://developer.android.com/studio/debug/dev-options#general) the Bluetooth Host Controller Interface (HCI) snoop log to start capturing Bluetooth traffic.
 5. Connect the phone to the computer with a USB cable and check that it is accessible with `adb devices`.
    ```console
    user@DESKTOP:~$ adb devices
    * daemon not running; starting now at tcp:5037
    * daemon started successfully
    List of devices attached
    CHISME10Plus18445 device
    ```
 6. Generate Bluetooth traffic between the phone and the watch using the App on the phone. Two strategies are available:
      - Make a capture of all Bluetooth traffic generated during normal use of the App. For example, capture all the traffic generated by the App by launching it, viewing some graph and closing the App. This helps to have an overview of the traffic generated by the App.
      - Do a single operation with the App, stop capturing traffic and examine the traffic generated. This helps to know what traffic is generated by a single operation on the App.
 7. Follow Google's [instructions](https://source.android.com/devices/bluetooth/verifying_debugging#debugging-with-bug-reports) to generate a Bluetooth service error report:
    ```
    adb shell dumpsys bluetooth_manager > dumpsys_out.txt
    ```
 8. Use the [script](https://cs.android.com/android/platform/superproject/+/master:packages/modules/Bluetooth/system/tools/scripts/btsnooz.py) ``btsnooz.py` to generate a Wireshark readable BTSnoop formatted file.
    ```
    python3 btsnooz.py dumpsys_out.txt > bt_capture.cfa
    ```
 9. Open the `bt_capture.cfa` file with Wireshark.

Steps 6, 7, 8 and 9 of the process are repeated as many times as necessary to gain as much knowledge about the communication protocol as possible. Steps 7 and 8 can be executed in a single line:
```
adb shell dumpsys bluetooth_manager | awk '/--- BEGIN:BTSNOOP_LOG_SUMMARY/ {found=1; next} /--- END:BTSNOOP_LOG_SUMMARY/ {found=0} {if (found) {print}}' | python3 btsnooz.py > bt_capture.cfa
```
To check that the `bt_capture.cfa` file has been generated correctly you can use `file` or read the contents with `btmon`:
```console
user@DESKTOP:~$ file bt_capture.cfa
bt_capture.cfa: BTSnoop version 1, HCI UART (H4)

user@DESKTOP:~$ btmon -r bt_capture.cfa | head
Bluetooth monitor ver 5.64
< HCI Command: Vendor (0x3f|0x011b) plen 0 #1 0.202176
< HCI Command: Vendor (0x3f|0x011b) plen 0 #2 0.202176
> HCI Event: Command Status (0x0f) plen 4 #3 0.202176
Vendor (0x3f|0x011b) ncmd 1
Status: Unknown HCI Command (0x01)
```

#### Common errors during traffic capture

If the `bt_capture.cfa` file has not been generated correctly several things can be checked:
 - The operation of adb.
    ```console
    user@DESKTOP:~$ adb devices
    List of devices attached
    CHISME10Plus18445 device

    user@DESKTOP:~$ adb shell uptime
    10:59:54 up 2 days, 15:18, 0 users, load average: 12.80, 13.00, 13.21
    ```
    The `adb devices` command lists the phones connected to the computer. The `adb shell uptime` command shows the time of the phone: `10:59:54`, and how long it has been on: `2 days, 15:18`.

 - If you get the error `unpack_from requires a buffer of at least 9 bytes for unpacking 9 bytes at offset 0 (current buffer size is 0)` check the output of `adb shell dumpsys bluetooth_manager`.
    ```console
    user@DESKTOP:~$ adb shell dumpsys bluetooth_manager | awk '/--- BEGIN:BTSNOOP_LOG_SUMMARY/ {found=1; next} /--- END:BTSNOOP_LOG_SUMMARY/ {found=0} {if (found) {print}} ' | python3 btsnooz.py > bt_capture.cfa
         Failed uudecoding...ensure input is a valid uuencoded stream.
         Traceback (most recent call last):
           File "/router/Conf/BT sniffing/adb/btsnooz.py", line 158, in main
             decode_snooz(base64.standard_b64decode(base64_string))
           File "/router/Conf/BT sniffing/adb/btsnooz.py", line 76, in decode_snooz
             version, last_timestamp_ms = struct.unpack_from('=bQ', snooz)
         struct.error: unpack_from requires a buffer of at least 9 bytes for unpacking 9 bytes at offset 0 (actual buffer size is 0)

         During handling of the above exception, another exception occurred:

         Traceback (most recent call last):
           File "/router/Conf/BT sniffing/adb/btsnooz.py", line 198, in <module>
             main()
           File "/router/Conf/BT sniffing/adb/btsnooz.py", line 162, in main
             sys.stderr.write(e)
         TypeError: write() argument must be str, not error
    ```
    
    The output of `adb shell dumpsys bluetooth_manager` must end with a block of lines delimited by `--- BEGIN:BTSNOOP_LOG_SUMMARY` and `--- END:BTSNOOP_LOG_SUMMARY` as shown here:
    ```console
    user@DESKTOP:~$ adb shell dumpsys bluetooth_manager
     ... [Lines cut off] ...
     BT Quality Report Events:
     Event queue is empty.
     --- BEGIN:BTSNOOP_LOG_SUMMARY (69696 bytes in) ---
     AgdDfxcoWAAAQtNFkOzMOrBGWvnk+VF3nSqIx+csXY+WcAKfl0mfl6mR5iqIaHt4qE+2C96QHgbryEBcm4MnwXgK/tQ7zr3W4MkAl6F3CnJr8K/ea7pORZR/zyDG0sMJ
     pQtNFkOzMOrBGWvnk+VF3nSqIx+csXY+WV4UzUJ15IMz1s4ny4sJLzSl0Q7OWDvfPy+CJ9Vux7HYqe//RJXF6h25dUdo3XIsyNUisli95ahi+Hh1VnzWOqs8a52V283K
     6riOA0rTBD5fp32+Tvr8Iqn5xRiao5mEzYxYzFPYhjozAHRYHs3K/vuH6DiLV/qPc3Sk5onRmx8Yw0Fy5K1AEe5TLDqCC+S4LsQYVyVd56kc9mGcDIhGZYWI1MpAqZPL
     BVwFkWEeHuz1TKBjEipeus9BZl6LVSUtWncrjm7CvxbpdYvK7gVUQdMEI71Aj/QCOdL8Xo0YaQ8n8NklfXapkeYqiGh7eLDXkVuLRai1tVhV0qZ1t+PoJvxrk163qZFe
     7r6Z0eA41v0PEFPUlQ==
     --- END:BTSNOOP_LOG_SUMMARY ---
    ```
    If this block of lines does not appear, check that the phone's Bluetooth is turned on and that the Bluetooth Host Controller Interface (HCI) snoop log is enabled, i.e. step 4 in the list above.


#### Bluetooth traffic analysis
In order to analyze the captured traffic it is important to have a clear understanding of how the Bluetooth Low Energy (BLE) protocol works. You can read this excellent [guide](https://reverse-engineering-ble-devices.readthedocs.io/en/latest/index.html) which is the one I used myself.

When opening the `bt_capture.cfa` file with Wireshark a window similar to this one appears:
![Ventana principal de Wireshark](https://user-images.githubusercontent.com/55441185/208170469-131df20f-288a-4f91-929a-4506989ad18f.png)
It may look quite intimidating, but Wireshark allows you to use filters to display only the packets relevant to your target.

At the first contact it is better to have an overview of all the traffic generated by the App when downloading the biometric data collected by the clock, so it is convenient to make a capture of the whole process, i.e.: 

 1. start the traffic capture on the phone (point 4 of "Capture Bluetooth traffic between the watch and the App").
 2. Start the App on the phone.
 3. Allow the App to collect the data stored in the watch.
 4. Close the App.
 5. Stop the traffic capture, i.e. disable the Bluetooth Host Controller Interface (HCI) search log.

Once this end-to-end traffic capture is done, the whole process of data collection by the App can be observed.

In the first part of the capture you can see a large number of packets with the HCI protocol. These packets do not contain useful information for our purpose.

![Paquetes HCI](https://user-images.githubusercontent.com/55441185/208172292-9d9dc3b5-c9cd-4744-840f-ac26690cf51d.png)

Next we are going to use `btatt` as a filter:

![Filtro btatt](https://user-images.githubusercontent.com/55441185/208172708-6dafe83b-decd-41ec-af48-39532cdd4bf8.png)

With this filter the packets with Bluetooth Attribute Protocol are shown. This protocol is used to send data at application level between Bluetooth Low Energy devices, i.e. with the `btatt` filter Wireshark will show only the packets in which the App asks the watch for information and the packets of the answers from the watch to the App.

At the beginning of the conversation between the App and the watch there are packets with the word GATT in the description, such as "GATT Primary Service Declaration". In this part of the conversation the phone is asking the watch what services and features it has. In the Bluetooth Low Energy protocol every piece of data that a device can give, such as the heart rate value given by a smart watch, is called a feature and a group of features is called a service.
Services and features have a unique identifier. At each connection, each of these unique identifiers is assigned a handle. This handle is what the phone App, or any other BLE client, will use to read or write data to the smartwatch. How to get the list of associated services, features and handles is detailed below.

Moving forward in the conversation between the phone and the watch you can see packets with data. Using the `btatt.value` filter only these packets are shown:

![Filtro btatt.value](https://user-images.githubusercontent.com/55441185/208172888-6555a5a1-29da-4969-983c-fb46cc55604f.png)

Selecting in the central panel Bluetooth Attribute Protocol and displaying its fields we can see the `Value` field, which in this case has a value of `0x01f01708`. This field is the data returned by the clock to a query made by the phone App. In the image above you can see that the request was made on packet 332, but to see packet 332 it is necessary to use the `btatt` filter again.

![Filtro batt](https://user-images.githubusercontent.com/55441185/208172965-b45fb1ff-6906-4e41-a378-c1215d8cfb54.png)


In the description of packet 332 and in its contents you can see that it is a read request using the handle `0x002a`. A handle is a number associated to a specific feature, or in other words, to read data from a feature you have to make a read request to its associated handle.
With the handle number and the returned value you can try to replicate the request to confirm that the Wireshark output is being interpreted correctly and that communication with the clock is possible programmatically.
A Bluetooth Low Energy scan is performed with `hcitool`:
```console
user@DESKTOP:~$ sudo timeout 10s hcitool lescan
LE Scan ...
66:GF:13:XX:XX:XX (unknown)
78:02:B7:XX:XX:XX N1(ID-XXXX)
F1:CG:BF:XX:XX:XX (unknown)
```
Cubot N1 watches are listed with a name like `N1(ID-XXXX)`, where XXXX is the last four digits of the MAC address. Once the MAC address is located, the `0x002a` handle read request is launched with `gatttool`:
```console
user@DESKTOP:~$ gatttool -b 78:02:B7:XX:XX:XX --char-read -a 0x002a
Characteristic value/descriptor: 01 f0 17 08
```
The value returned is the value that appears in the traffic capture that has been visualized with Wireshark, so it confirms that the interpretation that is being made of the BLE traffic capture is correct and that you can interact with the watch.

Once you know how to make simple queries to the watch, you need to figure out how the App gets the data with which it makes the graphs, such as the heart rate graph:

![Captura datos HR](https://user-images.githubusercontent.com/55441185/208173267-83b14858-8e9f-409b-97a4-9f9be4d1eb89.png)

At a glance, sorting by packet length in Wireshark, there are no packets longer than 255 bytes.

![Wireshark ordenado por longitud](https://user-images.githubusercontent.com/55441185/208173337-8a2b4896-7744-4dbc-aa84-33e37b449fe0.png)

If there are no large packets there must be many small packets, since the App graphs show several days. The easiest way to count the number of packets of each type is to use the `tshark` command in the console. `tshark` is installed with `sudo apt install tshark` and to count the number of packets of each type the command is executed:
```console
user@DESKTOP:~$ tshark -r bt_capture.cfa -T fields -e _ws.col.Info | sort | uniq -c | sort -n
1 Rcvd Command Status (Create Connection)
1 Sent Create Connection
2 Rcvd Command Status (LE Connection Update)
2 Rcvd Connect Complete
2 Rcvd Connection Parameter Update Request
2 Rcvd LE Meta (LE Connection Update Complete)
2 Sent Connection Parameter Update Response (Accepted)
2 Sent LE Connection Update
14 Rcvd Write Response, Handle: 0x0010 (Unknown)
14 Sent Write Request, Handle: 0x0010 (Unknown)
16 Rcvd Number of Completed Packets
232 Rcvd Handle Value Notification, Handle: 0x0015 (Unknown)
```

Note: To obtain in the console a CSV file with data similar to those displayed by Wireshark in the graphical interface, you can use the command:
```console
user@DESKTOP:~$ tshark -r bt_capture.cfa -T fields -E separator=, -E header=y -E quote=d -e frame.number -e frame.time_relative -e _ws.col.Source -e _ws.col.Destination -e _ws.col.Protocol -e _ws.col.Info
frame.number,frame.time_relative,_ws.col.Source,_ws.col.Destination,_ws.col.Protocol,_ws.col.Info
"1","0.000000000","localhost ()","remote ()","ATT","Sent Write Request, Handle: 0x0010 (Unknown)"
"2","0.006782000","controller","host","HCI_EVT","Rcvd Number of Completed Packets"
"3","0.247289000","remote ()","localhost ()","ATT","Rcvd Handle Value Notification, Handle: 0x0015 (Unknown)"
"4","0.252755000","remote ()","localhost ()","ATT","Rcvd Write Response, Handle: 0x0010 (Unknown)"
"5","0.287181000","remote ()","localhost ()","ATT","Rcvd Handle Value Notification, Handle: 0x0015 (Unknown)"
"6","0.366944000","remote ()","localhost ()","ATT","Rcvd Handle Value Notification, Handle: 0x0015 (Unknown)"
"7","0.406672000","remote ()","localhost ()","ATT","Rcvd Handle Value Notification, Handle: 0x0015 (Unknown)"
"8","1.379788000","localhost ()","remote ()","ATT","Sent Write Request, Handle: 0x0010 (Unknown)"
"9","1.406752000","controller","host","HCI_EVT","Rcvd Number of Completed Packets"
```

The fact that there are 232 packets of type `Rcvd Handle Value Notification, Handle: 0x0015 (Unknown)` is indicative that these are the packets used to pass the biometric data from the clock to the App. Using the Wireshark GUI you can search for these packets. There are so many that it does not take long to find them by moving the scroll bar. To show only those packets you can use the filter `btatt.opcode == 0x1b`:

![Filtro btatt.opcode == 0x1b](https://user-images.githubusercontent.com/55441185/208173418-a063612b-73ad-4892-be51-470db34ba29c.png)

Bluetooth Low Energy protocol notifications are packets that the GATT server (the watch in this case) sends to the client (the phone App in this case) with data, for example the battery charge level when it has reached a low level or the number of steps taken by the user in the last hour. Notifications can be sent at any time and their reception does not need to be confirmed. The client has to enable the sending of notifications of the types it wants and, once enabled, the server will send them without the client having to request them.
Since BLE notifications are sent by the watch without the App requesting them, at first glance it does not make sense for the watch to use BLE notifications to send the App data that is uploaded every time the App is launched on the phone. The notifications seem to be intended for asynchronous notifications between the GATT server (the watch in this case) and the client (the App on the phone in this case), not for sending data dumps on demand.

Further investigation is needed.

In the Wireshark GUI, using the filter `btatt.opcode == 0x1b` to show only the notifications, you can see that there are three batches of notifications in which the packet numbers (the first column) are correlative:

![Tanda notificaciones 1](https://user-images.githubusercontent.com/55441185/208173528-63db7d05-d7ce-4467-8590-51c12b7226d1.png)

![Tanda notificaciones 2](https://user-images.githubusercontent.com/55441185/208173570-a76b719e-3988-4f5a-a5e6-e1d95b89d55a.png)

![Tanda notificaciones 3](https://user-images.githubusercontent.com/55441185/208173584-e4817633-b033-4604-aeaf-eaf13b7668d3.png)

Packets 386, 622 and 662 appear to be the first of three series of notifications. If the filter is changed to `btatt`, to see packets with Bluetooth Attribute Protocol, a pattern appears:

![Tanda notificaciones 4](https://user-images.githubusercontent.com/55441185/208173995-76f73fba-d0cf-4923-8005-3c5bfcc53ba2.png)

![Tanda notificaciones 5](https://user-images.githubusercontent.com/55441185/208174002-f81900b5-d304-4513-8d70-1536f5d4babf.png)

![Tanda notificaciones 6](https://user-images.githubusercontent.com/55441185/208174014-64c566c7-2e0c-43e8-a1e9-2185a4d73f6f.png)

Just before each batch of notifications there is a write request to handle `0x0010` with its corresponding response. When displaying the content of the write request:

![Contenido petición escritura 1](https://user-images.githubusercontent.com/55441185/208174121-6863e86b-eb54-46be-874c-9f52057b9a24.png)

![Contenido petición escritura 2](https://user-images.githubusercontent.com/55441185/208174125-09ffdbae-2349-4d98-8d4a-83356ed36187.png)

![Contenido petición escritura 3](https://user-images.githubusercontent.com/55441185/208174133-c96049c7-6158-4bd7-9b9c-6e1452554359.png)

It appears that the data dumps are requested by the phone App by writing a value in the handle `0x0010` and that the data is sent from the clock to the phone via notifications.
It only remains to try to replicate the dumps from the command line to confirm that the way to perform the data dumps is to write in the handle `0x0010` the values `0xb2fa`, `0xf7fa07e50c110e0c` and `0x34fa`, and wait for the notifications.

As mentioned above, in order for the watch to send notifications you must first enable them. The `btatt.characteristic_configuration_client.notification == 1` filter is used to search the traffic capture for how the App has enabled notifications:

![Filtro btatt.characteristic_configuration_client.notification == 1](https://user-images.githubusercontent.com/55441185/208174421-4d5dec41-4665-46db-999d-c6c8cd32d2a8.png)

The App enables notifications by writing the value `0x0100` in the `0x0016` and `0x001f` handles. To replicate it in the console:
```console
user@DESKTOP:~$ gatttool -b 78:02:B7:XX:XX:XX --char-write-req -a 0x0016 -n 0100
Characteristic value was written successfully
user@DESKTOP:~$ gatttool -b 78:02:B7:XX:XX:XX:XX --char-write-req -a 0x001f -n 0100
Characteristic value was written successfully
```
And now the data dump requests:
```console
user@DESKTOP:~$ timeout --foreground 15s gatttool -b 78:02:B7:XX:XX:XX --char-write-req -a 0x0010 -n b2fa --listen
Characteristic value was written successfully
... [Líneas cortadas] ...
Notification handle = 0x0015 value: b2 07 e6 08 0d 0c 09 73 21 2d 0b 06 93 02 3a 0c 02 e0
Notification handle = 0x0015 value: b2 07 e6 08 0d 0d 04 00 2b 32 01 00 1e 00 3b 0c 03 e2
Notification handle = 0x0015 value: b2 07 e6 08 0d 0e 01 cc 00 00 00 00 00 00 35 06 01 cc
Notification handle = 0x0015 value: b2 07 e6 08 0d 0f 00 43 00 00 00 00 00 05 27 02 00 43
Notification handle = 0x0015 value: b2 07 e6 08 0d 10 00 49 00 00 00 00 00 29 2f 02 00 49
Notification handle = 0x0015 value: b2 07 e6 08 0d 11 00 2d 00 00 00 00 00 19 1d 01 00 2d
Notification handle = 0x0015 value: b2 fd 26

user@DESKTOP:~$ timeout --foreground 15s gatttool -b 78:02:B7:XX:XX:XX --char-write-req -a 0x0010 -n f7fa07e50c110e0c --listen
Characteristic value was written successfully
... [Líneas cortadas] ...
Notification handle = 0x0015 value: f7 07 e6 08 0d 0a 35 34 34 39 36 40 50 33 32 34 39 3a
Notification handle = 0x0015 value: f7 07 e6 08 0d 0c 5b 57 39 3d 33 37 3e 38 34 3b 41 30
Notification handle = 0x0015 value: f7 07 e6 08 0d 0e 3e 41 3f 6d 38 55 4c 39 53 43 73 56
Notification handle = 0x0015 value: f7 07 e6 08 0d 10 4b 47 58 4a 4e 55 4a 3c 3c 45 45 38
Notification handle = 0x0015 value: f7 07 e6 08 0d 12 38 39 3c 3f 36 3c 37 3b 34 34 33 37
Notification handle = 0x0015 value: f7 07 e6 08 0d 14 3d 35 37 35 36 33 30 ff ff ff ff ff
Notification handle = 0x0015 value: f7 fd cf

user@DESKTOP:~$ timeout --foreground 15s gatttool -b 78:02:B7:XX:XX:XX --char-write-req -a 0x0010 -n 34fa --listen
Characteristic value was written successfully
Notification handle = 0x0015 value: 34 fa 07 e6 07 07 10 00 ff ff ff 62 62 ff ff ff ff ff ff ff
Notification handle = 0x0015 value: 34 fa 07 e6 07 0a 0e 00 ff ff ff 62 62 ff ff ff ff ff ff ff
Notification handle = 0x0015 value: 34 fa 07 e6 07 0f 14 00 ff ff ff 62 62 ff ff ff ff ff ff ff
Notification handle = 0x0015 value: 34 fa 07 e6 07 10 0a 00 ff ff ff ff ff ff ff ff ff ff ff ff
Notification handle = 0x0015 value: 34 fa 07 e6 08 0d 0c 00 62 ff 62 ff ff ff ff ff ff ff ff ff
Notification handle = 0x0015 value: 34 fa 07 e6 08 0d 0e 00 62 ff 62 ff ff ff ff ff ff ff ff ff
Notification handle = 0x0015 value: 34 fa fd 10
```
Now that the way to make the dumps is known, it is necessary to try to find out what is the meaning of the data contained in the dumps.

## Confirm and extend the knowledge acquired in the previous step using small, easy to develop scripts.
In order to work in a more agile way, the dumps are saved in text files:
```console
user@DESKTOP:~$ timeout --foreground 15s gatttool -b 78:02:B7:XX:XX:XX --char-write-req -a 0x0010 -n b2fa --listen > b2fa.txt
user@DESKTOP:~$ timeout --foreground 15s gatttool -b 78:02:B7:XX:XX:XX --char-write-req -a 0x0010 -n f7fa07e50c110e0c --listen > f7fa.txt
user@DESKTOP:~$ timeout --foreground 15s gatttool -b 78:02:B7:XX:XX:XX --char-write-req -a 0x0010 -n 34fa --listen > 34fa.txt
```
### Dump of heart rate samples
Without more information than a list of hexadecimal digits it is difficult to discern the meaning of a data dump. However, at a glance it is possible to intuit something. Comparing two lines of different dumps:
```
   vv vv vv vv
b2 07 e6 08 0d 08 00 35 00 00 00 00 00 38 3b 02 00 35
f7 07 e6 08 0d 04 38 30 30 32 3b 3d 3a 34 34 33 31 31
   ^^ ^^ ^^ ^^
```
The digits `07 e6 08 0d` are repeated in the same position. Passing these numbers to decimal:
 - `07e6` = 2022
 - `08` = 8
 - `0d` = 13

These digits are the date, August 13, 2022, on which the dump has been made. If these three digits are the date, it is possible that the next digit is the time. For example, in the dump made with `f7fa07e50c110e0c` the following column:
```
               vv
f7 07 e6 08 0d 0a 35 34 34 39 36 40 50 33 32 34 39 3a
f7 07 e6 08 0d 0c 5b 57 39 3d 33 37 3e 38 34 3b 41 30
f7 07 e6 08 0d 0e 3e 41 3f 6d 38 55 4c 39 53 43 73 56
f7 07 e6 08 0d 10 4b 47 58 4a 4e 55 4a 3c 3c 45 45 38
f7 07 e6 08 0d 12 38 39 3c 3f 36 3c 37 3b 34 34 33 37
f7 07 e6 08 0d 14 3d 35 37 35 36 33 30 ff ff ff ff ff
               ^^
```
They are even numbers: `0a` = 10, `0c` = 12, `0e` = 14, `10` = 16, `12` = 18 and `14` = 20. Each of these even numbers is followed by 12 numbers. These 12 numbers could indicate the average value of some measurement in the 12 ten-minute stretches in two hours. If, in addition to the above, `ff` is assumed to indicate that the value does not exist or is incorrect, passing these numbers to decimal and displaying the dates gives :
```console
user@DESKTOP:~$ cat f7fa.txt | awk '{$1=$2=$3=$4=$5=""; printf "%03d %d-%02d-%02d %02d:00 ", "0x"$6, "0x"$7$8, "0x"$9, "0x"$10, "0x"$11; for (i = 12; i <= NF; i++) {if ($i == "ff") {printf "--- "} else {printf "%03d ", "0x"$i}}; print "" }'
247 2022-08-13 10:00 053 052 052 057 054 064 080 051 050 052 057 058
247 2022-08-13 12:00 091 087 057 061 051 055 062 056 052 059 065 048
247 2022-08-13 14:00 062 065 063 109 056 085 076 057 083 067 115 086
247 2022-08-13 16:00 075 071 088 074 078 085 074 060 060 069 069 056
247 2022-08-13 18:00 056 057 060 063 054 060 055 059 052 052 051 055
247 2022-08-13 20:00 061 053 055 053 054 051 048 --- --- --- --- ---
```
Making the `awk` script clearer and showing the hours and minutes:
```console
user@DESKTOP:~$ cat f7fa.txt | awk '
{
    $1=$2=$3=$4=$5=""
    printf "%03d %d-%02d-%02d ", "0x"$6, "0x"$7$8, "0x"$9, "0x"$10
    H="0x"$11
    M=0
    for (i = 12; i <= NF; i++) {
        if ($i == "ff") {
            printf "%02d:%02d: ---  ", H, M
        } else {
            printf "%02d:%02d: %03d  ", H, M, "0x"$i
        };
        M+=10
        if (M == 60) {
            H+=1
            M=0
        }
    }
    print ""
}'
247 2022-08-13 10:00: 053  10:10: 052  10:20: 052  10:30: 057  10:40: 054  10:50: 064  11:00: 080  11:10: 051  11:20: 050  11:30: 052  11:40: 057  11:50: 058  
247 2022-08-13 12:00: 091  12:10: 087  12:20: 057  12:30: 061  12:40: 051  12:50: 055  13:00: 062  13:10: 056  13:20: 052  13:30: 059  13:40: 065  13:50: 048  
247 2022-08-13 14:00: 062  14:10: 065  14:20: 063  14:30: 109  14:40: 056  14:50: 085  15:00: 076  15:10: 057  15:20: 083  15:30: 067  15:40: 115  15:50: 086  
247 2022-08-13 16:00: 075  16:10: 071  16:20: 088  16:30: 074  16:40: 078  16:50: 085  17:00: 074  17:10: 060  17:20: 060  17:30: 069  17:40: 069  17:50: 056  
247 2022-08-13 18:00: 056  18:10: 057  18:20: 060  18:30: 063  18:40: 054  18:50: 060  19:00: 055  19:10: 059  19:20: 052  19:30: 052  19:40: 051  19:50: 055  
247 2022-08-13 20:00: 061  20:10: 053  20:20: 055  20:30: 053  20:40: 054  20:50: 051  21:00: 048  21:10: ---  21:20: ---  21:30: ---  21:40: ---  21:50: ---
```
Contrasting these values with the values of the different graphs that the App has, it is verified that the dump made with `f7fa07e50c110e0c` corresponds to the dump of the heart rate data. Only a small adjustment remains. The heart rate values shown in each line are not those of the ten-minute sections of the two hours after the time indicated in the line, but of the two hours before. That is:
```
247 2022-08-13 18:00: 056 18:10: 057 18:20: 060 18:30: 063 18:40: 054 18:50: 060 19:00: 055 19:10: 059 19:20: 052 19:30: 052 19:40: 051 19:50: 055
```
should be:
```
247 2022-08-13 16:00: 056 16:10: 057 16:20: 060 16:30: 063 16:40: 054 16:50: 060 17:00: 055 17:10: 059 17:20: 052 17:30: 052 17:40: 051 17:50: 055
```
so the decimalization of the dump is:
```console
user@DESKTOP:~$ cat f7fa.txt | awk '
{
    $1=$2=$3=$4=$5=""
    printf "%03d %d-%02d-%02d ", "0x"$6, "0x"$7$8, "0x"$9, "0x"$10
    H=(("0x"$11) + 22) % 24
    M=0
    for (i = 12; i <= NF; i++) {
        if ($i == "ff") {
            printf "%02d:%02d: ---  ", H, M
        } else {
            printf "%02d:%02d: %03d  ", H, M, "0x"$i
        }
        M+=10
        if (M == 60) {
            H+=1
            M=0
        }
    }
    print ""
}'
247 2022-08-13 08:00: 053  08:10: 052  08:20: 052  08:30: 057  08:40: 054  08:50: 064  09:00: 080  09:10: 051  09:20: 050  09:30: 052  09:40: 057  09:50: 058  
247 2022-08-13 10:00: 091  10:10: 087  10:20: 057  10:30: 061  10:40: 051  10:50: 055  11:00: 062  11:10: 056  11:20: 052  11:30: 059  11:40: 065  11:50: 048  
247 2022-08-13 12:00: 062  12:10: 065  12:20: 063  12:30: 109  12:40: 056  12:50: 085  13:00: 076  13:10: 057  13:20: 083  13:30: 067  13:40: 115  13:50: 086  
247 2022-08-13 14:00: 075  14:10: 071  14:20: 088  14:30: 074  14:40: 078  14:50: 085  15:00: 074  15:10: 060  15:20: 060  15:30: 069  15:40: 069  15:50: 056  
247 2022-08-13 16:00: 056  16:10: 057  16:20: 060  16:30: 063  16:40: 054  16:50: 060  17:00: 055  17:10: 059  17:20: 052  17:30: 052  17:40: 051  17:50: 055  
247 2022-08-13 18:00: 061  18:10: 053  18:20: 055  18:30: 053  18:40: 054  18:50: 051  19:00: 048  19:10: ---  19:20: ---  19:30: ---  19:40: ---  19:50: ---
```
With this data it is now possible to make a graph of the heart rate measurements taken by the watch. Only one small detail remains. While the other two dump requests are made by sending a request with the values `0xb2fa` and `0x34fa`, the heart rate data dump request is made with `0xf7fa07e50c110e0c`. If you look closely at this value you can see that:
 - `07e5` = 2021
 - `0c` = 12
 - `11` = 17
 - `0e` = 14
 - `0c` = 12

These numbers correspond to a few days before the date on which the Bluetooth traffic capture was made: December 17, 2021 at 14:12. Making new heart rate data dump requests verifies that the date of the request is the date from which you want the dump to start and that the watch stores seven days of heart rate samples.

The summary of the knowledge obtained on how to get the heart rate data:

- The data dump is requested to the clock by writing in the handle `0x0010` a data dump start date in the following form:
  | - | Header | Year | Month | Day | Hour | Minutes|
  | :-- | :--: | :--: | :--: | :--: | :--: | :--: |
  | Hex | f7fa | 07e6 | 01 | 01 | 01 | 0c | 00|
  | Dec | 63482 | 2202 | 01 | 01 | 01 | 12 | 00|
- The dump is composed of notifications with the format:
  | - | Header | Year | Month | Day | Hour | H-2:00 | H-2:10 | H-2:20 | H-2:30 | H-2:40 | H-2:50 | H-1:00 | H-1:10 | H-1:20 | H-1:30 | H-1:40 | H-1:50 |
  | :-- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
  | Hex | f7 | 07e6 | 01 | 01 | 01 | 01 | 0c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c
  | Dec | 247 | 07e6 | 01 | 01 | 01 | 01 | 12 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60
  
  Where:
  - Header: value indicating that the notification is part of a heart rate data dump.
  - Year, Month and Day: date of the data collection included in the notification.
  - Time: time of collection of the data included in the notification. The rest of the notification is a list of data in which each piece of data is the average heart rate over a ten-minute period. The first value in the list is the average heart rate in the ten minutes starting two hours before the time specified in the Time field, the second value is the average of the ten minutes starting 110 minutes before the time specified in the Time field.... For example, if the Time field is 14, the data list will be the average heart rate in the time slots:
  	- 12:00 - 12:09
   	- 12:10 - 12:19
   	- 12:20 - 12:29
   	- 12:30 - 12:39
   	- 12:40 - 12:49
   	- 12:50 - 12:59
   	- 13:00 - 13:09
   	- 13:10 - 13:19
   	- 13:20 - 13:29
   	- 13:30 - 13:39
   	- 13:40 - 13:49
   	- 13:50 - 13:59
  - H-2:00: average heart rate in the time window starting at the value of the Hour minus 120 minutes field.
  - H-2:10: average heart rate in the time range starting at the Time field value minus 110 minutes.
  - H-2:20: average heart rate in the time range starting at the Time field value minus 100 minutes.
  - H-1:00: Average heart rate in the time range starting at the value in the Hour minus 60 minutes field.
  - H-1:10: Average heart rate in the time range starting at the value in the Hour minus 50 minutes field.
  - H-1:50: average heart rate in the time range starting at the value in the Hour minus 10 minutes field.
  - If the heart rate value is `ff` it indicates that there is no data.


Once you have understood the meaning of the different values in the heart rate dump, it will probably be much easier to do the same with the other two dumps, since they are probably similar.

### Dump of O<sub>2</sub> blood saturation samples
The dump performed by sending a request with the value `0x34fa` looks like this:
```
34 fa 07 e6 07 07 10 00 ff ff ff 62 62 ff ff ff ff ff ff ff
34 fa 07 e6 07 0a 0e 00 ff ff ff 62 62 ff ff ff ff ff ff ff
34 fa 07 e6 07 0f 14 00 ff ff ff 62 62 ff ff ff ff ff ff ff
34 fa 07 e6 07 10 0a 00 ff ff ff ff ff ff ff ff ff ff ff ff
34 fa 07 e6 08 0d 0c 00 62 ff 62 ff ff ff ff ff ff ff ff ff
34 fa 07 e6 08 0d 0e 00 62 ff 62 ff ff ff ff ff ff ff ff ff
```
Applying the same changes that have been made in the heart rate data dump you can switch to decimal with:
```console
user@DESKTOP:~$ cat 34fa.txt | awk '
{
    $1=$2=$3=$4=$5=""
    printf "%03d %03d %d-%02d-%02d ", "0x"$6, "0x"$7, "0x"$8$9, "0x"$10, "0x"$11
    H=(("0x"$12) + 22) % 24
    M=0
    for (i = 13; i <= NF; i++) {
        if ($i == "ff") {
            printf "%02d:%02d: ---  ", H, M
        } else {
            printf "%02d:%02d: %03d  ", H, M, "0x"$i
        }
        M+=10
        if (M == 60) {
            H+=1
            M=0
        }
    }
    print ""
}'
052 250 2022-07-07 14:00: 000  14:10: ---  14:20: ---  14:30: ---  14:40: 098  14:50: 098  15:00: ---  15:10: ---  15:20: ---  15:30: ---  15:40: ---  15:50: ---  16:00: ---  
052 250 2022-07-10 12:00: 000  12:10: ---  12:20: ---  12:30: ---  12:40: 098  12:50: 098  13:00: ---  13:10: ---  13:20: ---  13:30: ---  13:40: ---  13:50: ---  14:00: ---  
052 250 2022-07-15 18:00: 000  18:10: ---  18:20: ---  18:30: ---  18:40: 098  18:50: 098  19:00: ---  19:10: ---  19:20: ---  19:30: ---  19:40: ---  19:50: ---  20:00: ---  
052 250 2022-07-16 08:00: 000  08:10: ---  08:20: ---  08:30: ---  08:40: ---  08:50: ---  09:00: ---  09:10: ---  09:20: ---  09:30: ---  09:40: ---  09:50: ---  10:00: ---  
052 250 2022-08-13 10:00: 000  10:10: 098  10:20: ---  10:30: 098  10:40: ---  10:50: ---  11:00: ---  11:10: ---  11:20: ---  11:30: ---  11:40: ---  11:50: ---  12:00: ---  
052 250 2022-08-13 12:00: 000  12:10: 098  12:20: ---  12:30: 098  12:40: ---  12:50: ---  13:00: ---  13:10: ---  13:20: ---  13:30: ---  13:40: ---  13:50: ---  14:00: ---  
```










