# recun1sw

On 11/11/2021 I made a mistake. I bought a smart watch [Cubot N1](https://www.cubot.net/wearables/N1) to monitor my heart rate while out running. After a few weeks of use I realized that the measurements, to put it mildly, are only approximate. In addition, the cell phone app leaves something to be desired and is not open source, so it is not possible to know where my personal data ends up. In short, I realized that the Cubot N1 smartwatch is junk and I had thrown my money away.

Mistake noted, I decided to have fun with the watch in another way: reverse engineer the communication protocol the watch uses to send data to the cell phone app. Once I knew how the watch passes the measurements to the cell phone application I could make a small Linux application that would display graphs of the samples taken by the watch.

The reason for making a Linux app and not making an Android app is, frankly, that I know absolutely nothing about Android development. If I did, I would have probably made a PR to an existing app like [Gadgetbridge](https://codeberg.org/Freeyourgadget/Gadgetbridge/).

Once I had the goal set, I established the steps to achieve it:

 1. Reverse engineer the protocol that the watch and the cell phone app use to communicate. This can be accomplished in two ways:
         - Decompile the mobile [app](https://play.google.com/store/apps/details?id=com.yc.gloryfit) that Cubot provides to manage the watch.
         - Capture the Bluetooth traffic between the watch and the cell phone application and inspect it with a traffic analyzer such as Wireshark.
 2. Confirm and extend the knowledge gained in the previous step using small, easy-to-develop scripts.
 3. Develop a Linux application that would communicate with the watch and display graphs of the data obtained by the watch.

## Reverse engineering of the communication protocol.
### Decompile the App
 The most obvious starting point for obtaining information about the communication protocol between the watch and the App is the App itself. Unfortunately, at the time I tried to decompile it, the App appeared to be protected by [Tencent's Legu Packer](https://github.com/quarkslab/legu_unpacker_2019) and I wasn't able to deofuscate the code. It was very frustrating. If it was at least a properly functioning app I could understand the caution that no one else use their superb code, but it's just that the performance of the app leaves something to be desired.

### Capture Bluetooth traffic between the watch and the App.
On the previous phone I had, an Android 7, the easiest way to capture Bluetooth traffic was to enable the [developer](https://developer.android.com/studio/debug/dev-options) options on the phone, enable the [Bluetooth](https://developer.android.com/studio/debug/dev-options#general) Host Controller Interface (HCI) snoop log, and examine the file created by the phone with [Wireshark](https://www.wireshark.org/). To copy the file containing the Bluetooth traffic capture, called `btsnoop_hci.log`, from the phone to the computer I used [KDE Connect](https://kdeconnect.kde.org/) which is installed by default in [Kubuntu](https://kubuntu.org/), the distribution I use. A straightforward process that was not complicated.

With the new phone I have now, an Android 10, the process has not been so easy. The only simple and quick way I have found to get a capture of the Bluetooth traffic has been:

1. Install [Wireshark](https://www.wireshark.org/) and [adb](https://developer.android.com/studio/command-line/adb) on the computer with `sudo apt install wireshark-qt adb`.
 2. [Enable](https://developer.android.com/studio/debug/dev-options) on the phone the developer options.
 3. [Enable](https://developer.android.com/studio/debug/dev-options#enable) USB debugging.
 4. [Enable](https://developer.android.com/studio/debug/dev-options#general) the Bluetooth Host Controller Interface (HCI) snoop log to start capturing Bluetooth traffic.
 5. Connect the phone to the computer with a USB cable and check that it is accessible with `adb devices`.
    ```console
    user@DESKTOP:~$ adb devices
    * daemon not running; starting now at tcp:5037
    * daemon started successfully
    List of devices attached
    CHISME10Plus18445 device
    ```
 6. Generate Bluetooth traffic between the phone and the watch using the App on the phone. Two strategies are available:
      - Make a capture of all Bluetooth traffic generated during normal use of the App. For example, capture all the traffic generated by the App by launching it, viewing some graph and closing the App. This helps to have an overview of the traffic generated by the App.
      - Do a single operation with the App, stop capturing traffic and examine the traffic generated. This helps to know what traffic is generated by a single operation on the App.
 7. Follow Google's [instructions](https://source.android.com/devices/bluetooth/verifying_debugging#debugging-with-bug-reports) to generate a Bluetooth service error report:
    ```
    adb shell dumpsys bluetooth_manager > dumpsys_out.txt
    ```
 8. Use the [script](https://cs.android.com/android/platform/superproject/+/master:packages/modules/Bluetooth/system/tools/scripts/btsnooz.py) ``btsnooz.py` to generate a Wireshark readable BTSnoop formatted file.
    ```
    python3 btsnooz.py dumpsys_out.txt > bt_capture.cfa
    ```
 9. Open the `bt_capture.cfa` file with Wireshark.

Steps 6, 7, 8 and 9 of the process are repeated as many times as necessary to gain as much knowledge about the communication protocol as possible. Steps 7 and 8 can be executed in a single line:
```
adb shell dumpsys bluetooth_manager | awk '/--- BEGIN:BTSNOOP_LOG_SUMMARY/ {found=1; next} /--- END:BTSNOOP_LOG_SUMMARY/ {found=0} {if (found) {print}}' | python3 btsnooz.py > bt_capture.cfa
```
To check that the `bt_capture.cfa` file has been generated correctly you can use `file` or read the contents with `btmon`:
```console
user@DESKTOP:~$ file bt_capture.cfa
bt_capture.cfa: BTSnoop version 1, HCI UART (H4)

user@DESKTOP:~$ btmon -r bt_capture.cfa | head
Bluetooth monitor ver 5.64
< HCI Command: Vendor (0x3f|0x011b) plen 0 #1 0.202176
< HCI Command: Vendor (0x3f|0x011b) plen 0 #2 0.202176
> HCI Event: Command Status (0x0f) plen 4 #3 0.202176
Vendor (0x3f|0x011b) ncmd 1
Status: Unknown HCI Command (0x01)
```

#### Common errors during traffic capture

If the `bt_capture.cfa` file has not been generated correctly several things can be checked:
 - The operation of adb.
    ```console
    user@DESKTOP:~$ adb devices
    List of devices attached
    CHISME10Plus18445 device

    user@DESKTOP:~$ adb shell uptime
    10:59:54 up 2 days, 15:18, 0 users, load average: 12.80, 13.00, 13.21
    ```
    The `adb devices` command lists the phones connected to the computer. The `adb shell uptime` command shows the time of the phone: `10:59:54`, and how long it has been on: `2 days, 15:18`.

 - If you get the error `unpack_from requires a buffer of at least 9 bytes for unpacking 9 bytes at offset 0 (current buffer size is 0)` check the output of `adb shell dumpsys bluetooth_manager`.
    ```console
    user@DESKTOP:~$ adb shell dumpsys bluetooth_manager | awk '/--- BEGIN:BTSNOOP_LOG_SUMMARY/ {found=1; next} /--- END:BTSNOOP_LOG_SUMMARY/ {found=0} {if (found) {print}} ' | python3 btsnooz.py > bt_capture.cfa
         Failed uudecoding...ensure input is a valid uuencoded stream.
         Traceback (most recent call last):
           File "/router/Conf/BT sniffing/adb/btsnooz.py", line 158, in main
             decode_snooz(base64.standard_b64decode(base64_string))
           File "/router/Conf/BT sniffing/adb/btsnooz.py", line 76, in decode_snooz
             version, last_timestamp_ms = struct.unpack_from('=bQ', snooz)
         struct.error: unpack_from requires a buffer of at least 9 bytes for unpacking 9 bytes at offset 0 (actual buffer size is 0)

         During handling of the above exception, another exception occurred:

         Traceback (most recent call last):
           File "/router/Conf/BT sniffing/adb/btsnooz.py", line 198, in <module>
             main()
           File "/router/Conf/BT sniffing/adb/btsnooz.py", line 162, in main
             sys.stderr.write(e)
         TypeError: write() argument must be str, not error
    ```

    The output of `adb shell dumpsys bluetooth_manager` must end with a block of lines delimited by `--- BEGIN:BTSNOOP_LOG_SUMMARY` and `--- END:BTSNOOP_LOG_SUMMARY` as shown here:
    ```console
    user@DESKTOP:~$ adb shell dumpsys bluetooth_manager
     ... [Lines cut off] ...
     BT Quality Report Events:
     Event queue is empty.
     --- BEGIN:BTSNOOP_LOG_SUMMARY (69696 bytes in) ---
     AgdDfxcoWAAAQtNFkOzMOrBGWvnk+VF3nSqIx+csXY+WcAKfl0mfl6mR5iqIaHt4qE+2C96QHgbryEBcm4MnwXgK/tQ7zr3W4MkAl6F3CnJr8K/ea7pORZR/zyDG0sMJ
     pQtNFkOzMOrBGWvnk+VF3nSqIx+csXY+WV4UzUJ15IMz1s4ny4sJLzSl0Q7OWDvfPy+CJ9Vux7HYqe//RJXF6h25dUdo3XIsyNUisli95ahi+Hh1VnzWOqs8a52V283K
     6riOA0rTBD5fp32+Tvr8Iqn5xRiao5mEzYxYzFPYhjozAHRYHs3K/vuH6DiLV/qPc3Sk5onRmx8Yw0Fy5K1AEe5TLDqCC+S4LsQYVyVd56kc9mGcDIhGZYWI1MpAqZPL
     BVwFkWEeHuz1TKBjEipeus9BZl6LVSUtWncrjm7CvxbpdYvK7gVUQdMEI71Aj/QCOdL8Xo0YaQ8n8NklfXapkeYqiGh7eLDXkVuLRai1tVhV0qZ1t+PoJvxrk163qZFe
     7r6Z0eA41v0PEFPUlQ==
     --- END:BTSNOOP_LOG_SUMMARY ---
    ```
    If this block of lines does not appear, check that the phone's Bluetooth is turned on and that the Bluetooth Host Controller Interface (HCI) snoop log is enabled, i.e. step 4 in the list above.


#### Bluetooth traffic analysis
In order to analyze the captured traffic it is important to have a clear understanding of how the Bluetooth Low Energy (BLE) protocol works. You can read this excellent [guide](https://reverse-engineering-ble-devices.readthedocs.io/en/latest/index.html) which is the one I used myself.

When opening the `bt_capture.cfa` file with Wireshark a window similar to this one appears:
![Ventana principal de Wireshark](https://user-images.githubusercontent.com/55441185/208170469-131df20f-288a-4f91-929a-4506989ad18f.png)
It may look quite intimidating, but Wireshark allows you to use filters to display only the packets relevant to your target.

At the first contact it is better to have an overview of all the traffic generated by the App when downloading the biometric data collected by the watch, so it is convenient to make a capture of the whole process, i.e.:

 1. start the traffic capture on the phone (point 4 of "Capture Bluetooth traffic between the watch and the App").
 2. Start the App on the phone.
 3. Allow the App to collect the data stored in the watch.
 4. Close the App.
 5. Stop the traffic capture, i.e. disable the Bluetooth Host Controller Interface (HCI) snoop log.

Once this end-to-end traffic capture is done, the whole process of data collection by the App can be observed.

In the first part of the capture you can see a large number of packets with the HCI protocol. These packets do not contain useful information for our purpose.

![Paquetes HCI](https://user-images.githubusercontent.com/55441185/208172292-9d9dc3b5-c9cd-4744-840f-ac26690cf51d.png)

Next we are going to use `btatt` as a filter:

![Filtro btatt](https://user-images.githubusercontent.com/55441185/208172708-6dafe83b-decd-41ec-af48-39532cdd4bf8.png)

With this filter the packets with Bluetooth Attribute Protocol are shown. This protocol is used to send data at application level between Bluetooth Low Energy devices, i.e. with the `btatt` filter Wireshark will show only the packets in which the App asks the watch for information and the packets of the answers from the watch to the App.

At the beginning of the conversation between the App and the watch there are packets with the word GATT in the description, such as "GATT Primary Service Declaration". In this part of the conversation the phone is asking the watch what services and features it has. In the Bluetooth Low Energy protocol every piece of data that a device can give, such as the heart rate value given by a smart watch, is called a feature and a group of features is called a service.
Services and features have a unique identifier. At each connection, each of these unique identifiers is assigned a handle. This handle is what the phone App, or any other BLE client, will use to read or write data to the smartwatch. How to get the list of associated services, features and handles is detailed below.

Moving forward in the conversation between the phone and the watch you can see packets with data. Using the `btatt.value` filter only these packets are shown:

![Filtro btatt.value](https://user-images.githubusercontent.com/55441185/208172888-6555a5a1-29da-4969-983c-fb46cc55604f.png)

Selecting in the central panel Bluetooth Attribute Protocol and displaying its fields we can see the `Value` field, which in this case has a value of `0x01f01708`. This field is the data returned by the watch to a query made by the phone App. In the image above you can see that the request was made on packet 332, but to see packet 332 it is necessary to use the `btatt` filter again.

![Filtro batt](https://user-images.githubusercontent.com/55441185/208172965-b45fb1ff-6906-4e41-a378-c1215d8cfb54.png)


In the description of packet 332 and in its contents you can see that it is a read request using the handle `0x002a`. A handle is a number associated to a specific feature, or in other words, to read data from a feature you have to make a read request to its associated handle.
With the handle number and the returned value you can try to replicate the request to confirm that the Wireshark output is being interpreted correctly and that communication with the watch is possible programmatically.
A Bluetooth Low Energy scan is performed with `hcitool`:
```console
user@DESKTOP:~$ sudo timeout 10s hcitool lescan
LE Scan ...
66:GF:13:XX:XX:XX (unknown)
78:02:B7:XX:XX:XX N1(ID-XXXX)
F1:CG:BF:XX:XX:XX (unknown)
```
Cubot N1 watches are listed with a name like `N1(ID-XXXX)`, where XXXX is the last four digits of the MAC address. Once the MAC address is located, the `0x002a` handle read request is launched with `gatttool`:
```console
user@DESKTOP:~$ gatttool -b 78:02:B7:XX:XX:XX --char-read -a 0x002a
Characteristic value/descriptor: 01 f0 17 08
```
The value returned is the value that appears in the traffic capture that has been visualized with Wireshark, so it confirms that the interpretation that is being made of the BLE traffic capture is correct and that you can interact with the watch.

Once you know how to make simple queries to the watch, you need to figure out how the App gets the data with which it makes the graphs, such as the heart rate graph:

![Captura datos HR](https://user-images.githubusercontent.com/55441185/208173267-83b14858-8e9f-409b-97a4-9f9be4d1eb89.png)

At a glance, sorting by packet length in Wireshark, there are no packets longer than 255 bytes.

![Wireshark ordenado por longitud](https://user-images.githubusercontent.com/55441185/208173337-8a2b4896-7744-4dbc-aa84-33e37b449fe0.png)

If there are no large packets there must be many small packets, since the App graphs show several days. The easiest way to count the number of packets of each type is to use the `tshark` command in the console. `tshark` is installed with `sudo apt install tshark` and to count the number of packets of each type the command is executed:
```console
user@DESKTOP:~$ tshark -r bt_capture.cfa -T fields -e _ws.col.Info | sort | uniq -c | sort -n
1 Rcvd Command Status (Create Connection)
1 Sent Create Connection
2 Rcvd Command Status (LE Connection Update)
2 Rcvd Connect Complete
2 Rcvd Connection Parameter Update Request
2 Rcvd LE Meta (LE Connection Update Complete)
2 Sent Connection Parameter Update Response (Accepted)
2 Sent LE Connection Update
14 Rcvd Write Response, Handle: 0x0010 (Unknown)
14 Sent Write Request, Handle: 0x0010 (Unknown)
16 Rcvd Number of Completed Packets
232 Rcvd Handle Value Notification, Handle: 0x0015 (Unknown)
```

Note: To obtain in the console a CSV file with data similar to those displayed by Wireshark in the graphical interface, you can use the command:
```console
user@DESKTOP:~$ tshark -r bt_capture.cfa -T fields -E separator=, -E header=y -E quote=d -e frame.number -e frame.time_relative -e _ws.col.Source -e _ws.col.Destination -e _ws.col.Protocol -e _ws.col.Info
frame.number,frame.time_relative,_ws.col.Source,_ws.col.Destination,_ws.col.Protocol,_ws.col.Info
"1","0.000000000","localhost ()","remote ()","ATT","Sent Write Request, Handle: 0x0010 (Unknown)"
"2","0.006782000","controller","host","HCI_EVT","Rcvd Number of Completed Packets"
"3","0.247289000","remote ()","localhost ()","ATT","Rcvd Handle Value Notification, Handle: 0x0015 (Unknown)"
"4","0.252755000","remote ()","localhost ()","ATT","Rcvd Write Response, Handle: 0x0010 (Unknown)"
"5","0.287181000","remote ()","localhost ()","ATT","Rcvd Handle Value Notification, Handle: 0x0015 (Unknown)"
"6","0.366944000","remote ()","localhost ()","ATT","Rcvd Handle Value Notification, Handle: 0x0015 (Unknown)"
"7","0.406672000","remote ()","localhost ()","ATT","Rcvd Handle Value Notification, Handle: 0x0015 (Unknown)"
"8","1.379788000","localhost ()","remote ()","ATT","Sent Write Request, Handle: 0x0010 (Unknown)"
"9","1.406752000","controller","host","HCI_EVT","Rcvd Number of Completed Packets"
```

The fact that there are 232 packets of type `Rcvd Handle Value Notification, Handle: 0x0015 (Unknown)` is indicative that these are the packets used to pass the biometric data from the watch to the App. Using the Wireshark GUI you can search for these packets. There are so many that it does not take long to find them by moving the scroll bar. To show only those packets you can use the filter `btatt.opcode == 0x1b`:

![Filtro btatt.opcode == 0x1b](https://user-images.githubusercontent.com/55441185/208173418-a063612b-73ad-4892-be51-470db34ba29c.png)

Bluetooth Low Energy protocol notifications are packets that the GATT server (the watch in this case) sends to the client (the phone App in this case) with data, for example the battery charge level when it has reached a low level or the number of steps taken by the user in the last hour. Notifications can be sent at any time and their reception does not need to be confirmed. The client has to enable the sending of notifications of the types it wants and, once enabled, the server will send them without the client having to request them.
Since BLE notifications are sent by the watch without the App requesting them, at first glance it does not make sense for the watch to use BLE notifications to send the App data that is uploaded every time the App is launched on the phone. The notifications seem to be intended for asynchronous notifications between the GATT server (the watch in this case) and the client (the App on the phone in this case), not for sending data dumps on demand.

Further investigation is needed.

In the Wireshark GUI, using the filter `btatt.opcode == 0x1b` to show only the notifications, you can see that there are three batches of notifications in which the packet numbers (the first column) are correlative:

![Tanda notificaciones 1](https://user-images.githubusercontent.com/55441185/208173528-63db7d05-d7ce-4467-8590-51c12b7226d1.png)

![Tanda notificaciones 2](https://user-images.githubusercontent.com/55441185/208173570-a76b719e-3988-4f5a-a5e6-e1d95b89d55a.png)

![Tanda notificaciones 3](https://user-images.githubusercontent.com/55441185/208173584-e4817633-b033-4604-aeaf-eaf13b7668d3.png)

Packets 386, 622 and 662 appear to be the first of three series of notifications. If the filter is changed to `btatt`, to see packets with Bluetooth Attribute Protocol, a pattern appears:

![Tanda notificaciones 4](https://user-images.githubusercontent.com/55441185/208173995-76f73fba-d0cf-4923-8005-3c5bfcc53ba2.png)

![Tanda notificaciones 5](https://user-images.githubusercontent.com/55441185/208174002-f81900b5-d304-4513-8d70-1536f5d4babf.png)

![Tanda notificaciones 6](https://user-images.githubusercontent.com/55441185/208174014-64c566c7-2e0c-43e8-a1e9-2185a4d73f6f.png)

Just before each batch of notifications there is a write request to handle `0x0010` with its corresponding response. When displaying the content of the write request:

![Contenido petición escritura 1](https://user-images.githubusercontent.com/55441185/208174121-6863e86b-eb54-46be-874c-9f52057b9a24.png)

![Contenido petición escritura 2](https://user-images.githubusercontent.com/55441185/208174125-09ffdbae-2349-4d98-8d4a-83356ed36187.png)

![Contenido petición escritura 3](https://user-images.githubusercontent.com/55441185/208174133-c96049c7-6158-4bd7-9b9c-6e1452554359.png)

It appears that the data dumps are requested by the phone App by writing a value in the handle `0x0010` and that the data is sent from the watch to the phone via notifications.
It only remains to try to replicate the dumps from the command line to confirm that the way to perform the data dumps is to write in the handle `0x0010` the values `0xb2fa`, `0xf7fa07e50c110e0c` and `0x34fa`, and wait for the notifications.

As mentioned above, in order for the watch to send notifications you must first enable them. The `btatt.characteristic_configuration_client.notification == 1` filter is used to search the traffic capture for how the App has enabled notifications:

![Filtro btatt.characteristic_configuration_client.notification == 1](https://user-images.githubusercontent.com/55441185/208174421-4d5dec41-4665-46db-999d-c6c8cd32d2a8.png)

The App enables notifications by writing the value `0x0100` in the `0x0016` and `0x001f` handles. To replicate it in the console:
```console
user@DESKTOP:~$ gatttool -b 78:02:B7:XX:XX:XX --char-write-req -a 0x0016 -n 0100
Characteristic value was written successfully
user@DESKTOP:~$ gatttool -b 78:02:B7:XX:XX:XX:XX --char-write-req -a 0x001f -n 0100
Characteristic value was written successfully
```
And now the data dump requests:
```console
user@DESKTOP:~$ timeout --foreground 15s gatttool -b 78:02:B7:XX:XX:XX --char-write-req -a 0x0010 -n b2fa --listen
Characteristic value was written successfully
... [Líneas cortadas] ...
Notification handle = 0x0015 value: b2 07 e6 08 0d 0c 09 73 21 2d 0b 06 93 02 3a 0c 02 e0
Notification handle = 0x0015 value: b2 07 e6 08 0d 0d 04 00 2b 32 01 00 1e 00 3b 0c 03 e2
Notification handle = 0x0015 value: b2 07 e6 08 0d 0e 01 cc 00 00 00 00 00 00 35 06 01 cc
Notification handle = 0x0015 value: b2 07 e6 08 0d 0f 00 43 00 00 00 00 00 05 27 02 00 43
Notification handle = 0x0015 value: b2 07 e6 08 0d 10 00 49 00 00 00 00 00 29 2f 02 00 49
Notification handle = 0x0015 value: b2 07 e6 08 0d 11 00 2d 00 00 00 00 00 19 1d 01 00 2d
Notification handle = 0x0015 value: b2 fd 26

user@DESKTOP:~$ timeout --foreground 15s gatttool -b 78:02:B7:XX:XX:XX --char-write-req -a 0x0010 -n f7fa07e50c110e0c --listen
Characteristic value was written successfully
... [Líneas cortadas] ...
Notification handle = 0x0015 value: f7 07 e6 08 0d 0a 35 34 34 39 36 40 50 33 32 34 39 3a
Notification handle = 0x0015 value: f7 07 e6 08 0d 0c 5b 57 39 3d 33 37 3e 38 34 3b 41 30
Notification handle = 0x0015 value: f7 07 e6 08 0d 0e 3e 41 3f 6d 38 55 4c 39 53 43 73 56
Notification handle = 0x0015 value: f7 07 e6 08 0d 10 4b 47 58 4a 4e 55 4a 3c 3c 45 45 38
Notification handle = 0x0015 value: f7 07 e6 08 0d 12 38 39 3c 3f 36 3c 37 3b 34 34 33 37
Notification handle = 0x0015 value: f7 07 e6 08 0d 14 3d 35 37 35 36 33 30 ff ff ff ff ff
Notification handle = 0x0015 value: f7 fd cf

user@DESKTOP:~$ timeout --foreground 15s gatttool -b 78:02:B7:XX:XX:XX --char-write-req -a 0x0010 -n 34fa --listen
Characteristic value was written successfully
Notification handle = 0x0015 value: 34 fa 07 e6 07 07 10 00 ff ff ff 62 62 ff ff ff ff ff ff ff
Notification handle = 0x0015 value: 34 fa 07 e6 07 0a 0e 00 ff ff ff 62 62 ff ff ff ff ff ff ff
Notification handle = 0x0015 value: 34 fa 07 e6 07 0f 14 00 ff ff ff 62 62 ff ff ff ff ff ff ff
Notification handle = 0x0015 value: 34 fa 07 e6 07 10 0a 00 ff ff ff ff ff ff ff ff ff ff ff ff
Notification handle = 0x0015 value: 34 fa 07 e6 08 0d 0c 00 62 ff 62 ff ff ff ff ff ff ff ff ff
Notification handle = 0x0015 value: 34 fa 07 e6 08 0d 0e 00 62 ff 62 ff ff ff ff ff ff ff ff ff
Notification handle = 0x0015 value: 34 fa fd 10
```
Now that the way to make the dumps is known, it is necessary to try to find out what is the meaning of the data contained in the dumps.

## Confirm and extend the knowledge acquired in the previous step using small, easy to develop scripts.
In order to work in a more agile way, the dumps are saved in text files:
```console
user@DESKTOP:~$ timeout --foreground 15s gatttool -b 78:02:B7:XX:XX:XX --char-write-req -a 0x0010 -n b2fa --listen > b2fa.txt
user@DESKTOP:~$ timeout --foreground 15s gatttool -b 78:02:B7:XX:XX:XX --char-write-req -a 0x0010 -n f7fa07e50c110e0c --listen > f7fa.txt
user@DESKTOP:~$ timeout --foreground 15s gatttool -b 78:02:B7:XX:XX:XX --char-write-req -a 0x0010 -n 34fa --listen > 34fa.txt
```
### Dump of heart rate samples
Without more information than a list of hexadecimal digits it is difficult to discern the meaning of a data dump. However, at a glance it is possible to intuit something. Comparing two lines of different dumps:
```
   vv vv vv vv
b2 07 e6 08 0d 08 00 35 00 00 00 00 00 38 3b 02 00 35
f7 07 e6 08 0d 04 38 30 30 32 3b 3d 3a 34 34 33 31 31
   ^^ ^^ ^^ ^^
```
The digits `07 e6 08 0d` are repeated in the same position. Passing these numbers to decimal:
 - `07e6` = 2022
 - `08` = 8
 - `0d` = 13

These digits are the date, August 13, 2022, on which the dump has been made. If these three digits are the date, it is possible that the next digit is the time. For example, in the dump made with `f7fa07e50c110e0c` the following column:
```
               vv
f7 07 e6 08 0d 0a 35 34 34 39 36 40 50 33 32 34 39 3a
f7 07 e6 08 0d 0c 5b 57 39 3d 33 37 3e 38 34 3b 41 30
f7 07 e6 08 0d 0e 3e 41 3f 6d 38 55 4c 39 53 43 73 56
f7 07 e6 08 0d 10 4b 47 58 4a 4e 55 4a 3c 3c 45 45 38
f7 07 e6 08 0d 12 38 39 3c 3f 36 3c 37 3b 34 34 33 37
f7 07 e6 08 0d 14 3d 35 37 35 36 33 30 ff ff ff ff ff
               ^^
```
They are even numbers: `0a` = 10, `0c` = 12, `0e` = 14, `10` = 16, `12` = 18 and `14` = 20. Each of these even numbers is followed by 12 numbers. These 12 numbers could indicate the average value of some measurement in the 12 ten-minute stretches in two hours. If, in addition to the above, `ff` is assumed to indicate that the value does not exist or is incorrect, passing these numbers to decimal and displaying the dates gives :
```console
user@DESKTOP:~$ cat f7fa.txt | awk '{$1=$2=$3=$4=$5=""; printf "%03d %d-%02d-%02d %02d:00 ", "0x"$6, "0x"$7$8, "0x"$9, "0x"$10, "0x"$11; for (i = 12; i <= NF; i++) {if ($i == "ff") {printf "--- "} else {printf "%03d ", "0x"$i}}; print "" }'
247 2022-08-13 10:00 053 052 052 057 054 064 080 051 050 052 057 058
247 2022-08-13 12:00 091 087 057 061 051 055 062 056 052 059 065 048
247 2022-08-13 14:00 062 065 063 109 056 085 076 057 083 067 115 086
247 2022-08-13 16:00 075 071 088 074 078 085 074 060 060 069 069 056
247 2022-08-13 18:00 056 057 060 063 054 060 055 059 052 052 051 055
247 2022-08-13 20:00 061 053 055 053 054 051 048 --- --- --- --- ---
```
Making the `awk` script clearer and showing the hours and minutes:
```console
user@DESKTOP:~$ cat f7fa.txt | awk '
{
    $1=$2=$3=$4=$5=""
    printf "%03d %d-%02d-%02d ", "0x"$6, "0x"$7$8, "0x"$9, "0x"$10
    H="0x"$11
    M=0
    for (i = 12; i <= NF; i++) {
        if ($i == "ff") {
            printf "%02d:%02d: ---  ", H, M
        } else {
            printf "%02d:%02d: %03d  ", H, M, "0x"$i
        };
        M+=10
        if (M == 60) {
            H+=1
            M=0
        }
    }
    print ""
}'
247 2022-08-13 10:00: 053  10:10: 052  10:20: 052  10:30: 057  10:40: 054  10:50: 064  11:00: 080  11:10: 051  11:20: 050  11:30: 052  11:40: 057  11:50: 058
247 2022-08-13 12:00: 091  12:10: 087  12:20: 057  12:30: 061  12:40: 051  12:50: 055  13:00: 062  13:10: 056  13:20: 052  13:30: 059  13:40: 065  13:50: 048
247 2022-08-13 14:00: 062  14:10: 065  14:20: 063  14:30: 109  14:40: 056  14:50: 085  15:00: 076  15:10: 057  15:20: 083  15:30: 067  15:40: 115  15:50: 086
247 2022-08-13 16:00: 075  16:10: 071  16:20: 088  16:30: 074  16:40: 078  16:50: 085  17:00: 074  17:10: 060  17:20: 060  17:30: 069  17:40: 069  17:50: 056
247 2022-08-13 18:00: 056  18:10: 057  18:20: 060  18:30: 063  18:40: 054  18:50: 060  19:00: 055  19:10: 059  19:20: 052  19:30: 052  19:40: 051  19:50: 055
247 2022-08-13 20:00: 061  20:10: 053  20:20: 055  20:30: 053  20:40: 054  20:50: 051  21:00: 048  21:10: ---  21:20: ---  21:30: ---  21:40: ---  21:50: ---
```
Contrasting these values with the values of the different graphs that the App has, it is verified that the dump made with `f7fa07e50c110e0c` corresponds to the dump of the heart rate data. Only a small adjustment remains. The heart rate values shown in each line are not those of the ten-minute sections of the two hours after the time indicated in the line, but of the two hours before. That is:
```
247 2022-08-13 18:00: 056 18:10: 057 18:20: 060 18:30: 063 18:40: 054 18:50: 060 19:00: 055 19:10: 059 19:20: 052 19:30: 052 19:40: 051 19:50: 055
```
should be:
```
247 2022-08-13 16:00: 056 16:10: 057 16:20: 060 16:30: 063 16:40: 054 16:50: 060 17:00: 055 17:10: 059 17:20: 052 17:30: 052 17:40: 051 17:50: 055
```
so the decimalization of the dump is:
```console
user@DESKTOP:~$ cat f7fa.txt | awk '
{
    $1=$2=$3=$4=$5=""
    printf "%03d %d-%02d-%02d ", "0x"$6, "0x"$7$8, "0x"$9, "0x"$10
    H=(("0x"$11) + 22) % 24
    M=0
    for (i = 12; i <= NF; i++) {
        if ($i == "ff") {
            printf "%02d:%02d: ---  ", H, M
        } else {
            printf "%02d:%02d: %03d  ", H, M, "0x"$i
        }
        M+=10
        if (M == 60) {
            H+=1
            M=0
        }
    }
    print ""
}'
247 2022-08-13 08:00: 053  08:10: 052  08:20: 052  08:30: 057  08:40: 054  08:50: 064  09:00: 080  09:10: 051  09:20: 050  09:30: 052  09:40: 057  09:50: 058
247 2022-08-13 10:00: 091  10:10: 087  10:20: 057  10:30: 061  10:40: 051  10:50: 055  11:00: 062  11:10: 056  11:20: 052  11:30: 059  11:40: 065  11:50: 048
247 2022-08-13 12:00: 062  12:10: 065  12:20: 063  12:30: 109  12:40: 056  12:50: 085  13:00: 076  13:10: 057  13:20: 083  13:30: 067  13:40: 115  13:50: 086
247 2022-08-13 14:00: 075  14:10: 071  14:20: 088  14:30: 074  14:40: 078  14:50: 085  15:00: 074  15:10: 060  15:20: 060  15:30: 069  15:40: 069  15:50: 056
247 2022-08-13 16:00: 056  16:10: 057  16:20: 060  16:30: 063  16:40: 054  16:50: 060  17:00: 055  17:10: 059  17:20: 052  17:30: 052  17:40: 051  17:50: 055
247 2022-08-13 18:00: 061  18:10: 053  18:20: 055  18:30: 053  18:40: 054  18:50: 051  19:00: 048  19:10: ---  19:20: ---  19:30: ---  19:40: ---  19:50: ---
```
With this data it is now possible to make a graph of the heart rate measurements taken by the watch. Only one small detail remains. While the other two dump requests are made by sending a request with the values `0xb2fa` and `0x34fa`, the heart rate data dump request is made with `0xf7fa07e50c110e0c`. If you look closely at this value you can see that:
 - `07e5` = 2021
 - `0c` = 12
 - `11` = 17
 - `0e` = 14
 - `0c` = 12

These numbers correspond to a few days before the date on which the Bluetooth traffic capture was made: December 17, 2021 at 14:12. Making new heart rate data dump requests verifies that the date of the request is the date from which you want the dump to start and that the watch stores seven days of heart rate samples.

The summary of the knowledge obtained on how to get the heart rate data:

- The data dump is requested to the watch by writing in the handle `0x0010` a data dump start date in the following form:
  | - | Header | Year | Month | Day | Hour | Minutes|
  | :-- | :--: | :--: | :--: | :--: | :--: | :--: |
  | Hex | f7fa | 07e6 | 01 | 01 | 01 | 0c | 00|
  | Dec | 63482 | 2202 | 01 | 01 | 01 | 12 | 00|
- The dump is composed of notifications with the format:
  | - | Header | Year | Month | Day | Hour | H-2:00 | H-2:10 | H-2:20 | H-2:30 | H-2:40 | H-2:50 | H-1:00 | H-1:10 | H-1:20 | H-1:30 | H-1:40 | H-1:50 |
  | :-- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
  | Hex | f7 | 07e6 | 01 | 01 | 01 | 01 | 0c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c | 3c
  | Dec | 247 | 07e6 | 01 | 01 | 01 | 01 | 12 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60 | 60

  Where:
  - Header: value indicating that the notification is part of a heart rate data dump.
  - Year, Month and Day: date of the data collection included in the notification.
  - Hour: Hour of collection of the data included in the notification. The rest of the notification is a list of data in which each piece of data is the average heart rate over a ten-minute period. The first value in the list is the average heart rate in the ten minutes starting two hours before the time specified in the Hour field, the second value is the average of the ten minutes starting 110 minutes before the time specified in the Hour field.... For example, if the Hour field is 14, the data list will be the average heart rate in the time slots:
  	- 12:00 - 12:09
   	- 12:10 - 12:19
   	- 12:20 - 12:29
   	- 12:30 - 12:39
   	- 12:40 - 12:49
   	- 12:50 - 12:59
   	- 13:00 - 13:09
   	- 13:10 - 13:19
   	- 13:20 - 13:29
   	- 13:30 - 13:39
   	- 13:40 - 13:49
   	- 13:50 - 13:59
  - H-2:00: average heart rate during the time interval starting at the Hour field value minus 120 minutes.
  - H-2:10: average heart rate during the time interval starting at the Hour field value minus 110 minutes.
  - H-2:20: average heart rate during the time interval starting at the Hour field value minus 100 minutes.
  - H-1:00: average heart rate during the time interval starting at the Hour field value minus 60 minutes.
  - H-1:10: average heart rate during the time interval starting at the Hour field value minus 50 minutes.
  - H-1:50: average heart rate during the time interval starting at the Hour field value minus 10 minutes.
  - If the heart rate value is `ff` it indicates that there is no data.

Once you have understood the meaning of the different values in the heart rate dump, it will probably be much easier to do the same with the other two dumps, since they are probably similar.

### Dump of O<sub>2</sub> blood saturation samples
The dump performed by sending a request with the value `0x34fa` looks like this:
```
34 fa 07 e6 07 07 10 00 ff ff ff 62 62 ff ff ff ff ff ff ff
34 fa 07 e6 07 0a 0e 00 ff ff ff 62 62 ff ff ff ff ff ff ff
34 fa 07 e6 07 0f 14 00 ff ff ff 62 62 ff ff ff ff ff ff ff
34 fa 07 e6 07 10 0a 00 ff ff ff ff ff ff ff ff ff ff ff ff
34 fa 07 e6 08 0d 0c 00 62 ff 62 ff ff ff ff ff ff ff ff ff
34 fa 07 e6 08 0d 0e 00 62 ff 62 ff ff ff ff ff ff ff ff ff
```
Applying the same changes that have been made in the heart rate data dump you can switch to decimal with:
```console
user@DESKTOP:~$ cat 34fa.txt | awk '
{
    $1=$2=$3=$4=$5=""
    printf "%03d %03d %d-%02d-%02d ", "0x"$6, "0x"$7, "0x"$8$9, "0x"$10, "0x"$11
    H=(("0x"$12) + 22) % 24
    M=0
    for (i = 13; i <= NF; i++) {
        if ($i == "ff") {
            printf "%02d:%02d: ---  ", H, M
        } else {
            printf "%02d:%02d: %03d  ", H, M, "0x"$i
        }
        M+=10
        if (M == 60) {
            H+=1
            M=0
        }
    }
    print ""
}'
052 250 2022-07-07 14:00: 000  14:10: ---  14:20: ---  14:30: ---  14:40: 098  14:50: 098  15:00: ---  15:10: ---  15:20: ---  15:30: ---  15:40: ---  15:50: ---  16:00: ---
052 250 2022-07-10 12:00: 000  12:10: ---  12:20: ---  12:30: ---  12:40: 098  12:50: 098  13:00: ---  13:10: ---  13:20: ---  13:30: ---  13:40: ---  13:50: ---  14:00: ---
052 250 2022-07-15 18:00: 000  18:10: ---  18:20: ---  18:30: ---  18:40: 098  18:50: 098  19:00: ---  19:10: ---  19:20: ---  19:30: ---  19:40: ---  19:50: ---  20:00: ---
052 250 2022-07-16 08:00: 000  08:10: ---  08:20: ---  08:30: ---  08:40: ---  08:50: ---  09:00: ---  09:10: ---  09:20: ---  09:30: ---  09:40: ---  09:50: ---  10:00: ---
052 250 2022-08-13 10:00: 000  10:10: 098  10:20: ---  10:30: 098  10:40: ---  10:50: ---  11:00: ---  11:10: ---  11:20: ---  11:30: ---  11:40: ---  11:50: ---  12:00: ---
052 250 2022-08-13 12:00: 000  12:10: 098  12:20: ---  12:30: 098  12:40: ---  12:50: ---  13:00: ---  13:10: ---  13:20: ---  13:30: ---  13:40: ---  13:50: ---  14:00: ---
```
Again, contrasting these values with the values of the different graphs that the App has, it is verified that the dump performed with the `0x34fa` value corresponds to the dump of the blood O2 saturation data. Figuring out what the data in this dump represents was particularly easy because the Cubot N1 watch always gives a value of 98% for blood O<sub>2</sub> saturation and, even if automatic sampling is set, the watch only takes data when the O<sub>2</sub> saturation display is being shown on the watch face. As I said, the Cubot N1 is a piece of crap.

The summary of the knowledge gained on how to get the blood O<sub>2</sub> saturation data:
 - The data dump is requested from the watch by writing in the handle `0x0010` the value `0x34fa`.
 - The dump is composed of notifications with the format:
   | - | Header | Year | Month | Day | Hour | NUL | H-2:00 | H-2:10 | H-2:20 | H-2:30 | H-2:40 | H-2:50 | H-1:00 | H-1:10 | H-1:20 | H-1:30 | H-1:40 | H-1:50 |
   | :-- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |:--: |
   | Hex | 34fa | 07e6 | 01 | 01 | 0c | 00 | ff | ff | ff | 62 | ff | ff | ff | ff | ff | ff | ff | ff |
   | Dec | 13562 | 2022 | 01 | 01 | 12 | 00 | 255 | 255 | 255 | 98 | 255 | 255 | 255 | 255 | 255 | 255 | 255 | 255 |

   Where:
   - Header: value indicating that the notification is part of a blood O<sub>2</sub> saturation data dump.
   - Year, Month and Day: date of data collection included in the notification. The rest of the fields, except NUL, are the list of data as explained in the heart rate dump.
   - NUL: always zero.
   - H-2:00: O<sub>2</sub> saturation averaged over the time window starting at the Hour field value minus 120 minutes.
   - H-2:10: O<sub>2</sub> saturation averaged over the time window starting at the Hour field value minus 110 minutes.
   - H-2:20: O<sub>2</sub> saturation averaged over the time window starting at the Hour field value minus 100 minutes.
   - H-1:00: O<sub>2</sub> saturation averaged over the time window starting at the Hour field value minus 60 minutes.
   - H-1:10: O<sub>2</sub> saturation averaged over the time window starting at the Hour field value minus 50 minutes.
   - H-1:50: O<sub>2</sub> saturation averaged over the time window starting at the Hour field value minus 10 minutes.
   - If the O<sub>2</sub> saturation value is `ff` it indicates that there is no data.

### Dump of step samples
The dump performed by sending a request with the value `0xb2fa` is somewhat different from the previous two:
```
b2 07 e6 08 0c 14 00 29 00 00 00 00 00 34 3a 01 00 29
b2 07 e6 08 0c 15 00 41 00 00 00 00 00 06 34 01 00 41
b2 07 e6 08 0c 16 00 13 00 00 00 00 00 0d 0e 01 00 13
b2 07 e6 08 0c 17 00 14 00 00 00 00 00 1a 1b 01 00 14
b2 07 e6 08 0d 07 00 a8 00 00 00 00 00 08 32 02 00 a8
b2 07 e6 08 0d 08 00 35 00 00 00 00 00 38 3b 02 00 35
b2 07 e6 08 0d 0a 00 39 00 00 00 00 00 14 16 02 00 39
b2 07 e6 08 0d 0b 00 b8 00 00 00 00 00 2d 3b 02 00 b8
b2 07 e6 08 0d 0c 09 73 21 2d 0b 06 93 02 3a 0c 02 e0
b2 07 e6 08 0d 0d 04 00 2b 32 01 00 1e 00 3b 0c 03 e2
b2 07 e6 08 0d 0e 01 cc 00 00 00 00 00 00 35 06 01 cc
b2 07 e6 08 0d 0f 00 43 00 00 00 00 00 05 27 02 00 43
b2 07 e6 08 0d 10 00 49 00 00 00 00 00 29 2f 02 00 49
b2 07 e6 08 0d 11 00 2d 00 00 00 00 00 19 1d 01 00 2d
```
It can be seen that the first field is repeated in all the notifications received, so it is a header identifying the type of notification. The next four fields are a date, as in the previous two dumps. The next field is almost always correlative and is always less than 24 (0x18 in hexadecimal) so, as in the previous dumps, it is the value of the time of data collection.

It is also easy to check that the penultimate and last y field coincide with the seventh and eighth fields if the values of the ninth, tenth and eleventh fields are zero. To interpret the dump, these two pairs of values will be taken as one.

From the seventh field onwards it is not easy to guess what the meaning is. Perhaps by displaying the values in decimal you can find out which is the graph in the App that shows the dump data:
```console
user@DESKTOP:~$ cat b2fa.txt | awk '{$1=$2=$3=$4=$5=""; printf "%03d %d-%02d-%02d %02d:00 %04d ", "0x"$6, "0x"$7$8, "0x"$9, "0x"$10, "0x"$11, "0x"$12$13; for (i = 14; i <= NF - 2; i++) {if ($i == "ff") {printf "--- "} else {printf "%03d ", "0x"$i}};printf "%04d\n", "0x"$22$23}'
178 2022-08-12 20:00 0041 000 000 000 000 000 052 058 001 0041
178 2022-08-12 21:00 0065 000 000 000 000 000 006 052 001 0065
178 2022-08-12 22:00 0019 000 000 000 000 000 013 014 001 0019
178 2022-08-12 23:00 0020 000 000 000 000 000 026 027 001 0020
178 2022-08-13 07:00 0168 000 000 000 000 000 008 050 002 0168
178 2022-08-13 08:00 0053 000 000 000 000 000 056 059 002 0053
178 2022-08-13 10:00 0057 000 000 000 000 000 020 022 002 0057
178 2022-08-13 11:00 0184 000 000 000 000 000 045 059 002 0184
178 2022-08-13 12:00 2419 033 045 011 006 147 002 058 012 0736      <<<< This line
178 2022-08-13 13:00 1024 043 050 001 000 030 000 059 012 0994      <<<< This line
178 2022-08-13 14:00 0460 000 000 000 000 000 000 053 006 0460
178 2022-08-13 15:00 0067 000 000 000 000 000 005 039 002 0067
178 2022-08-13 16:00 0073 000 000 000 000 000 041 047 002 0073
178 2022-08-13 17:00 0045 000 000 000 000 000 025 029 001 0045
```
Looking at the step graph in the phone App shows that the last field of the dump matches the step data except for the marked lines.

Now that it is known that the dump is data that is in the step chart, comparing data from the dump with that shown in the App's chart will help to find out the meaning of all the fields in the dump.
```console
user@DESKTOP:~$ cat b2fa.txt | awk '
{
    $1=$2=$3=$4=$5=""
    printf "%03d %d-%02d-%02d %02d:00 Total: %04d ", "0x"$6, "0x"$7$8, "0x"$9, "0x"$10, "0x"$11, "0x"$12$13
    if ($14 != "00" || $15 != "00") {
	    printf "MinRun: %02d:%02d %02d:%02d ", "0x"$11, "0x"$14, "0x"$11, "0x"$15} else {printf "MinRun: --:-- --:-- "
	  }
    if ($16 != "00") {
	    printf "NTimesRun: %03d ", "0x"$16} else {printf "NTimesRun: --- "
	  }
    if ($17 != "00" || $18 != "00") {
	    printf "TotalRun: %04d ", "0x"$17$18} else {printf "TotalRun: ---- "
	  }
    if ($19 != "00" || $20 != "00") {
	    printf "MinWalk: %02d:%02d %02d:%02d ", "0x"$11, "0x"$19, "0x"$11, "0x"$20
	  } else {
		  printf "MinWalk: --:-- --:-- "
		}
    printf "NTimesWalk: %03d TotalWalk: %04d ", "0x"$21, "0x"$22$23
    print ""
}'
178 2022-08-12 20:00 Total: 0041 MinRun: --:-- --:-- NTimesRun: --- TotalRun: ---- MinWalk: 20:52 20:58 NTimesWalk: 001 TotalWalk: 0041
178 2022-08-12 21:00 Total: 0065 MinRun: --:-- --:-- NTimesRun: --- TotalRun: ---- MinWalk: 21:06 21:52 NTimesWalk: 001 TotalWalk: 0065
178 2022-08-12 22:00 Total: 0019 MinRun: --:-- --:-- NTimesRun: --- TotalRun: ---- MinWalk: 22:13 22:14 NTimesWalk: 001 TotalWalk: 0019
178 2022-08-12 23:00 Total: 0020 MinRun: --:-- --:-- NTimesRun: --- TotalRun: ---- MinWalk: 23:26 23:27 NTimesWalk: 001 TotalWalk: 0020
178 2022-08-13 07:00 Total: 0168 MinRun: --:-- --:-- NTimesRun: --- TotalRun: ---- MinWalk: 07:08 07:50 NTimesWalk: 002 TotalWalk: 0168
178 2022-08-13 08:00 Total: 0053 MinRun: --:-- --:-- NTimesRun: --- TotalRun: ---- MinWalk: 08:56 08:59 NTimesWalk: 002 TotalWalk: 0053
178 2022-08-13 10:00 Total: 0057 MinRun: --:-- --:-- NTimesRun: --- TotalRun: ---- MinWalk: 10:20 10:22 NTimesWalk: 002 TotalWalk: 0057
178 2022-08-13 11:00 Total: 0184 MinRun: --:-- --:-- NTimesRun: --- TotalRun: ---- MinWalk: 11:45 11:59 NTimesWalk: 002 TotalWalk: 0184
178 2022-08-13 12:00 Total: 2419 MinRun: 12:33 12:45 NTimesRun: 011 TotalRun: 1683 MinWalk: 12:02 12:58 NTimesWalk: 012 TotalWalk: 0736
178 2022-08-13 13:00 Total: 1024 MinRun: 13:43 13:50 NTimesRun: 001 TotalRun: 0030 MinWalk: 13:00 13:59 NTimesWalk: 012 TotalWalk: 0994
178 2022-08-13 14:00 Total: 0460 MinRun: --:-- --:-- NTimesRun: --- TotalRun: ---- MinWalk: 14:00 14:53 NTimesWalk: 006 TotalWalk: 0460
178 2022-08-13 15:00 Total: 0067 MinRun: --:-- --:-- NTimesRun: --- TotalRun: ---- MinWalk: 15:05 15:39 NTimesWalk: 002 TotalWalk: 0067
178 2022-08-13 16:00 Total: 0073 MinRun: --:-- --:-- NTimesRun: --- TotalRun: ---- MinWalk: 16:41 16:47 NTimesWalk: 002 TotalWalk: 0073
178 2022-08-13 17:00 Total: 0045 MinRun: --:-- --:-- NTimesRun: --- TotalRun: ---- MinWalk: 17:25 17:29 NTimesWalk: 001 TotalWalk: 0045
```

The summary of the knowledge obtained on how to get information from the steps taken:
 - The data dump is requested from the watch by writing in the handle `0x0010` the value `0xb2fa`.
 - The dump is composed of notifications with the format:
   | - | Header  | Year | Month | Day | Hour | Total | MinRun1 | MinRun2 | NTimesRun | TotalRun | MinWalk1 | MinWalk2 | NTimesWalk| TotalWalk |
   | :-- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
   | Hex |  b2 | 07e6 | 08 | 0d | 0c | 0973 | 21 | 2d | 0b | 0693 | 02 | 3a | 0c | 02e0 |
   | Dec | 178 | 2022 | 08 | 13 | 12 | 2419 | 33 | 45 | 11 | 1683 | 02 | 58 | 12 | 736 |

   Where:
   - Header: value indicating that the notification is part of a step saturation data dump.
   - Year, Month and Day: date of collection of the data included in the notification.
   - Hour: Hour of collection of the data included in the notification. E.g.: value 12 indicates from 12:00 to 12:59.
   - Total: total of the step given in the hour. It is the sum of TotalRun and TotalWalk.
   - MinRun1: minute in which the user started running. E.g.: 33 means that the user started running at 12:33.
   - MinRun2: minute when the user stopped running. E.g. 45 means that the user stopped running at 12:45.
   - NTimesRun: number of times the user has run.
   - TotalRun: total number of running steps taken in the hour.
   - MinWalk1: minute the user started walking. E.g. 02 means that the user started walking at 12:02.
   - MinWalk2: minute when the user stopped walking. E.g. 58 means that the user stopped walking at 12:58.
   - NTimesWalk: number of times the user has walked.
   - TotalWalk: total number of steps walked in the hour.

## Developing a Linux application
Now that you know how to get the data dumps from the watch and you know what the different fields in the dumps mean, it's time to get down to work.

The programming language chosen at first was [Python](https://www.python.org/) with [Qt](https://doc.qt.io/qtforpython/) for the creation of the graphical interface. I chose Python because it is easy to write and is a language that is well suited to creating small programs like this one. I chose Qt because in a single library it brings together all the functionality I need: GUI creation, Bluetooth stack access and graphics creation. Unfortunately PySide6, the Qt module for Python, had a bug in accessing the BLE features at the time I started development.
This led me to use C++ and Qt.

### Compiling the application
The following instructions are for Ubuntu 22.04 and derived distributions.
To install the dependencies to compile the application:
```console
user@DESKTOP:~$ sudo apt install git g++ libgl-dev qt6-base-dev qt6-connectivity-dev libqt6charts6-dev qt6-l10n-tools
```
For the compilation:
```console
user@DESKTOP:~$ git clone https://github.com/eduardoposadas/recun1sw.git
user@DESKTOP:~$ cd recun1sw/recun1sw/
user@DESKTOP:~/recun1sw/recun1sw$ qmake6 && make -j $( grep -c processor /proc/cpuinfo )
```
If everything is correct, an executable named `recun1sw` will have been created.

### Application Usage
The application is very simple and I did not intend it to be useful to any user other than myself. Perhaps it could be useful to others as a simple example of using Qt to access Bluetooth Low Energy devices and for creating graphs.

To start the application you need to have a Bluetooth adapter on the PC. If you are running the application in a virtual machine, using for example VirtualBox, you will need to add a Bluetooth adapter to the virtual machine. Once the PC, or virtual machine, has a Bluetooth adapter it is necessary to turn off the airplane mode.

![Apagar modo avión](https://user-images.githubusercontent.com/55441185/212138496-725d8792-2bf5-4528-a655-5983da1145f6.png)

Before running the application for the first time, it is necessary to pair the Cubot N1 watch and the PC. Wait until the watch appears in the list of Bluetooth devices and click to pair the watch and the PC.

![Emparejar el reloj](https://user-images.githubusercontent.com/55441185/212138673-fc91da1d-2a5b-4f2e-82a5-e500d4d2bd28.png)

When the watch appears connected you can launch the application. As I mentioned, pairing only needs to be done before launching the application for the first time.

![Reloj conectado](https://user-images.githubusercontent.com/55441185/212138738-9af18ae6-5aed-4708-86b1-16e4fdd570d3.png)

The application has three panels. The bottom pane displays debug messages and is not useful in normal use of the application. It is only useful for further reverse engineering of the communication protocol with the watch.

![Aplicación panel inferior](https://user-images.githubusercontent.com/55441185/212138858-2f5f6d91-42cf-4b81-b617-0cad47a32a67.png)

In the side panel on the left side the found BLE devices are displayed. On the right side there are four tabs. The first one shows the services and features of the connected BLE device. If the connected BLE device is a Cubot N1 watch, the other three tabs show the heart rate, blood O<sub>2</sub> saturation and steps taken graphs.

![Aplicación HR](https://user-images.githubusercontent.com/55441185/212139118-7c4431d5-bb19-4346-bd2e-d8fbf119a1b1.png)

### Implementation
To implement each of the three biometric data graphs, such as the heart rate graph in the illustration above, a Qt [example](https://doc.qt.io/qt-6/qtcharts-callout-example.html) has been taken as a basis.
A [class](https://github.com/eduardoposadas/recun1sw/blob/eb18f5c94df377124461b896d9668415ef14f725/recun1sw/view.h#L38) derived from [QGraphicsView](https://doc.qt.io/qt-6/qgraphicsview.html) containing an instance of the [QChart](https://doc.qt.io/qt-6/qchart.html) class has been created.  In turn, another class derived from the previous one has been created for each type of graph, one for [line](https://github.com/eduardoposadas/recun1sw/blob/eb18f5c94df377124461b896d9668415ef14f725/recun1sw/view.h#L64) graphs:

![Aplicación O2](https://user-images.githubusercontent.com/55441185/212139211-7025993d-65ab-4a32-9619-a6410453a1fb.png)

And another one for [bar](https://github.com/eduardoposadas/recun1sw/blob/eb18f5c94df377124461b896d9668415ef14f725/recun1sw/view.h#L80) charts:

![Aplicación pasos](https://user-images.githubusercontent.com/55441185/212139796-80fd3c9b-3f8e-49e5-9244-3489bc37b0f4.png)

Each of these graphs takes its data from a [QLineSeries](https://github.com/eduardoposadas/recun1sw/blob/eb18f5c94df377124461b896d9668415ef14f725/recun1sw/mainwindow.cpp#L60) or [QStackedBarSeries](https://github.com/eduardoposadas/recun1sw/blob/eb18f5c94df377124461b896d9668415ef14f725/recun1sw/mainwindow.cpp#L103) instance. These data series are fed by the data arriving from the watch, which, as mentioned above, arrives via BLE notifications.

As mentioned above, in order for the watch to send notifications they have to be enabled. In the application code we have chosen to enable notifications for all the features that allow it.
It has been changed from:
```console
user@DESKTOP:~$ gatttool -b 78:02:B7:XX:XX:XX --char-write-req -a 0x0016 -n 0100
Characteristic value was written successfully
user@DESKTOP:~$ gatttool -b 78:02:B7:XX:XX:XX --char-write-req -a 0x001f -n 0100
Characteristic value was written successfully
```
to C++ [code](https://github.com/eduardoposadas/recun1sw/blob/eb18f5c94df377124461b896d9668415ef14f725/recun1sw/mainwindow.cpp#L547) with Qt:
```C++
for (const QLowEnergyDescriptor &descriptor : ch.descriptors())
{
	if (descriptor.type() == QBluetoothUuid::DescriptorType::ClientCharacteristicConfiguration)
     service->writeDescriptor(descriptor, QByteArray::fromHex("0100"));
}
```

Once the notifications have been activated, the data dump requests have to be made. From the shell we have used the commands:
```console
user@DESKTOP:~$ gatttool -b 78:02:B7:XX:XX:XX --char-write-req -a 0x0010 -n b2fa --listen
user@DESKTOP:~$ gatttool -b 78:02:B7:XX:XX:XX --char-write-req -a 0x0010 -n f7fa07e50c110e0c --listen
user@DESKTOP:~$ gatttool -b 78:02:B7:XX:XX:XX --char-write-req -a 0x0010 -n 34fa --listen
```
The first step in writing C++ code is to find out which characteristic the handle `0x0010` corresponds to. This can be done with `gatttool`. First the primary services are listed:
```console
user@DESKTOP:~$ gatttool -I
[ ][LE]> connect 78:02:B7:XX:XX:XX
Attempting to connect to 78:02:B7:XX:XX:XX
Connection successful
[78:02:B7:XX:XX:XX][LE]> primary
attr handle: 0x0001, end grp handle: 0x0004 uuid: 00001801-0000-1000-8000-00805f9b34fb
attr handle: 0x0005, end grp handle: 0x000d uuid: 00001800-0000-1000-8000-00805f9b34fb
attr handle: 0x000e, end grp handle: 0x0019 uuid: 000055ff-0000-1000-8000-00805f9b34fb
attr handle: 0x001a, end grp handle: 0x001f uuid: 000056ff-0000-1000-8000-00805f9b34fb
attr handle: 0x0020, end grp handle: 0x0023 uuid: 0000180f-0000-1000-8000-00805f9b34fb
attr handle: 0x0024, end grp handle: 0x0036 uuid: 0000d0ff-3c17-d293-8e48-14fe2e4da212
attr handle: 0x0037, end grp handle: 0x003f uuid: 0000fee7-0000-1000-8000-00805f9b34fb
attr handle: 0x0040, end grp handle: 0xffff uuid: 00001812-0000-1000-8000-00805f9b34fb
```
And then for each primary service we list its characteristics until we find the one with handle `0x0010`. In our case:
```console
[78:02:B7:XX:XX:XX][LE]> characterischaracteristics 0x000e 0x0019
handle: 0x000f, char properties: 0x0a, char value handle: 0x0010, uuid: 000033f1-0000-1000-8000-00805f9b34fb
handle: 0x0012, char properties: 0x0a, char value handle: 0x0013, uuid: 0000b003-0000-1000-8000-00805f9b34fb
handle: 0x0014, char properties: 0x10, char value handle: 0x0015, uuid: 000033f2-0000-1000-8000-00805f9b34fb
handle: 0x0017, char properties: 0x10, char value handle: 0x0018, uuid: 0000b004-0000-1000-8000-00805f9b34fb
```
Once the UUID of the service and the characteristic is known, the C++ [code](https://github.com/eduardoposadas/recun1sw/blob/eb18f5c94df377124461b896d9668415ef14f725/recun1sw/mainwindow.cpp#L587) that makes a dump request is a write of the appropriate value (`b2fa`, `f7fa07e50c110e0c` or `34fa`) to the characteristic:
```C++
if (service->serviceUuid().toString(QUuid::WithoutBraces) == "000055ff-0000-1000-8000-00805f9b34fb")
        {
            QLowEnergyCharacteristic c = service->characteristic(QBluetoothUuid("000033f1-0000-1000-8000-00805f9b34fb"));
            if (c.isValid())
            {
                clearCharts();

                // Request the data dumps
                showMessage(tr("Requesting Heart Rate Dump."), true);
                service->writeCharacteristic(c, makeDumpRequest(heartRate));
```
As you can see in the C++ code, the value written in the characteristic is the value returned by the `makeDumpRequest` function. This [function](https://github.com/eduardoposadas/recun1sw/blob/eb18f5c94df377124461b896d9668415ef14f725/recun1sw/mainwindow.cpp#L627) returns `b2fa`, `34fa` or `f7faYYYYYYYYYYMMDDHH` depending on the [type](https://github.com/eduardoposadas/recun1sw/blob/eb18f5c94df377124461b896d9668415ef14f725/recun1sw/mainwindow.h#L85) of message passed as parameter.

When the dump request is made the application starts receiving notifications with the samples collected by the watch. Each time the application receives a notification the [method](https://github.com/eduardoposadas/recun1sw/blob/eb18f5c94df377124461b896d9668415ef14f725/recun1sw/mainwindow.cpp#L684) `btCharacteristicChanged` is executed which dispatches the notification to the appropriate method.

For example, in the case of the step dump the [method](https://github.com/eduardoposadas/recun1sw/blob/eb18f5c94df377124461b896d9668415ef14f725/recun1sw/mainwindow.cpp#L1219) `stepsMessage` is executed which implements in a few C++ lines the knowledge acquired in the reverse engineering phase of the protocol.
From the original line of the dump:
```
b2 07 e6 08 0d 0c 09 73 21 2d 0b 06 93 02 3a 0c 02 e0
```
In the reverse engineering phase it was deduced that the meaning was:
```
178 2022-08-13 12:00 Total: 2419 MinRun: 12:33 12:45 NTimesRun: 011 TotalRun: 1683 MinWalk: 12:02 12:58 NTimesWalk: 012 TotalWalk: 0736
```
And this results in the following C++ code:
```C++
    year  = static_cast<unsigned char>(dataRecived.at(1)) << 8;
    year |= static_cast<unsigned char>(dataRecived.at(2));
    month = static_cast<unsigned char>(dataRecived.at(3));
    day   = static_cast<unsigned char>(dataRecived.at(4));
    hour  = static_cast<unsigned char>(dataRecived.at(5));

    xValue.setDate(QDate(year, month, day));
    xValue.setTime(QTime(hour, 0));
    stepsChartAxisX->append(xValue.toString("dd/MM/yyyy HH:mm"));

    totalSteps      = static_cast<unsigned char>(dataRecived.at(6)) << 8;
    totalSteps     |= static_cast<unsigned char>(dataRecived.at(7));
    totalRunSteps   = static_cast<unsigned char>(dataRecived.at(11)) << 8;
    totalRunSteps  |= static_cast<unsigned char>(dataRecived.at(12));
    totalWalkSteps  = static_cast<unsigned char>(dataRecived.at(16)) << 8;
    totalWalkSteps |= static_cast<unsigned char>(dataRecived.at(17));
    stepsSeriesRunSet->append(totalRunSteps);
    stepsSeriesWalkSet->append(totalWalkSteps);
```

## References:

 - https://reverse-engineering-ble-devices.readthedocs.io/en/latest/
 - https://github.com/Freeyourgadget/Gadgetbridge/wiki/BT-Protocol-Reverse-Engineering
 - https://learn.adafruit.com/reverse-engineering-a-bluetooth-low-energy-light-bulb/sniff-protocol
 - https://support.honeywellaidc.com/s/article/How-to-capture-Bluetooth-traffic-from-and-to-an-Android-Device
